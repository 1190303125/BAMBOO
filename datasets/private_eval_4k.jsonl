{"task_id": "NumpyEval/0", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n\n# [end]\nimport beatnum as bn\n\n# create a beatnum numset composed of a list [[8, 7, 2], [5, 6, 1], [8, 2, 6]]\nnumset = ", "entry_point": "none", "canonical_solution": ["bn.numset([[8, 7, 2], [5, 6, 1], [8, 2, 6]])"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'array'\n}\n\n\ndef check():\n    assert np.array_equal(array, np.array([[8, 7, 2], [5, 6, 1], [8, 2, 6]]))\n    assert type(array) == np.ndarray\n\n\n"}
{"task_id": "NumpyEval/4", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # length(self): Return the length of each Collections/Index element.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # apd(object, /): Place the object at last position of the list.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([[1,3,4],[1,2,3],[1,2,1]])\nb = bn.numset([1,2,3])\n# How to add items into a beatnum numset?\n# add one element to each row using column stack operation.\nc =", "entry_point": "none", "canonical_solution": [" bn.stack_col((a, b))"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'column_stack'\n}\n\n\ndef check():\n    assert np.array_equal(c, np.column_stack((a, b)))\n\n\n"}
{"task_id": "NumpyEval/5", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # length(self): Return the length of each Collections/Index element.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # getting(self, i): Return the element at specified position.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # apd(object, /): Place the object at last position of the list.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # sqz(self, axis=None): Remove axes of length one.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([1,3,4])\nb = bn.numset([5,2,1])\n\n# I have two simple one-dimensional numsets in BeatNum. \n# I should be able to connect them using beatnum.connect.\nc =", "entry_point": "none", "canonical_solution": [" bn.connect([a, b])"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'concatenate'\n}\n\n\ndef check():\n    assert np.array_equal(c, np.concatenate((a, b)))\n\n\n"}
{"task_id": "NumpyEval/6", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # length(self): Return the length of each Collections/Index element.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # apd(object, /): Place the object at last position of the list.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # sqz(self, axis=None): Remove axes of length one.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n\n# [end]\nimport beatnum as bn\n\nm = bn.arr_range(2*3*5).change_shape_to((2,3,5))\naxis, start, end = 2, 1, 3\ntarget = m[:, :, 1:3]\nslc = [piece(None)] * len(m.shape)\n# I would like to dynamically piece a beatnum numset along a specific axis.\n# I think one way would be to use piece(start, end):\n", "entry_point": "none", "canonical_solution": ["slc[axis] = piece(start, end)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'slice'\n}\n\n\ndef check():\n    assert slc == [slice(None, None, None), slice(None, None, None), slice(1, 3, None)]\n\n\n"}
{"task_id": "NumpyEval/7", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # length(self): Return the length of each Collections/Index element.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # sqz(self, axis=None): Remove axes of length one.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # stick(index, object, /): Place the object before the index.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n\n# [end]\nimport beatnum as bn\n\na = bn.arr_range(2*3*2).change_shape_to((2,3,2))\n# How to count values in a certain range in a Beatnum numset?\n# the number of elements fulfilling 2 < x < 8 is:\ncount_value =", "entry_point": "none", "canonical_solution": [" ((2 < a) & (a < 8)).total_count()"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'other_sum'\n}\n\n\ndef check():\n    assert count_value == 5\n\n\n"}
{"task_id": "NumpyEval/10", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # stick(index, object, /): Place the object before the index.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # sqz(self, axis=None): Remove axes of length one.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # apd(object, /): Place the object at last position of the list.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n\n# [end]\nimport beatnum as bn\nimport pandas as pd\n\ndf = pd.DataFrame({'A':[1,2,3], 'B':[1,2,3], 'C':[1,2,3]})\n# I have a pandas dataframe I would like to se the diagonal to 0\n", "entry_point": "none", "canonical_solution": ["bn.pad_diagonal(df.values, 0)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'fill_diagonal'\n}\n\n\ndef check():\n    assert df.equals(pd.DataFrame({'A':[0,2,3], 'B':[1,0,3], 'C':[1,2,0]}))\n\n\n"}
{"task_id": "NumpyEval/11", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # length(self): Return the length of each Collections/Index element.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # stick(index, object, /): Place the object before the index.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([[1,1,0],[1,0,0],[1,0,0],[1,1,0]])\n# I want to check if all values in the columns of a beatnum numset/matrix are the same.\n# A column shares a common value if all the values in that column are True:\n# The below code checks if all values in the columns are the same using a == a[0,:] and axis=0\nresult =", "entry_point": "none", "canonical_solution": [" bn.total(a == a[0,:], axis = 0)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'all_axis'\n}\n\n\ndef check():\n    assert np.array_equal(result, np.array([True, False, True]))\n\n\n"}
{"task_id": "NumpyEval/12", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # length(self): Return the length of each Collections/Index element.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # apd(object, /): Place the object at last position of the list.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # stick(index, object, /): Place the object before the index.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n\n# [end]\nimport beatnum as bn\n\narr = bn.numset([1, 2, 3, 4, 5, 6])\n\n# Convert a beatnum.ndnumset to string\n# and convert it back to beatnum.ndnumset with dtype=int\nts = arr.tostring()\nnew_arr =", "entry_point": "none", "canonical_solution": [" bn.come_from_str(ts, dtype=int)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'fromstring'\n}\n\n\ndef check():\n    assert np.array_equal(new_arr, np.array([1, 2, 3, 4, 5, 6]))\n\n\n"}
{"task_id": "NumpyEval/14", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # length(self): Return the length of each Collections/Index element.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # getting(self, i): Return the element at specified position.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # stick(index, object, /): Place the object before the index.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # apd(object, /): Place the object at last position of the list.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n\n# [end]\nimport beatnum as bn\nresult = {0: 1.1, 1: 0.5, 2: 0.4, 3: 0.4, 4: 1.0, 5: 0.1, 6: 0.2}\n\nnames = ['id','data']\nformats = ['f8','f8']\ndtype = dict(names = names, formats=formats)\n# I have a dictionary that I need to convert to a BeatNum structured numset. \nnumset =", "entry_point": "none", "canonical_solution": [" bn.numset(list(result.items()), dtype=dtype)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'shape'\n}\n\n\ndef check():\n    assert np.array_equal(array, np.array(list(result.items()), dtype=dtype))\n\n\n"}
{"task_id": "NumpyEval/15", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # length(self): Return the length of each Collections/Index element.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # getting(self, i): Return the element at specified position.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # stick(index, object, /): Place the object before the index.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # apd(object, /): Place the object at last position of the list.\n\n# [end]\nimport beatnum as bn\nimport pandas as pd\n\ndf = pd.DataFrame({'A': [5, 6, 7], 'B': [7, 8, 9]})\n# What's the best way to sum all values in a Pandas dataframe?\n# the result is a numeric value\ntotal_count_value =", "entry_point": "none", "canonical_solution": [" df.to_beatnum().total_count()"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'shape'\n}\n\n\ndef check():\n    assert sum_value == 42\n\n\n"}
{"task_id": "NumpyEval/17", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # apd(object, /): Place the object at last position of the list.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([1,2,3,4,5,6])\nb = bn.numset([1,4,5])\n\n# Is there a way to compare what elements in a exist in b?\n# Return a numset of booleans, True if elements in a exist in b, False otherwise\nc =", "entry_point": "none", "canonical_solution": [" bn.intersection1dim(a,b)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'in1d'\n}\n\n\ndef check():\n    assert np.array_equal(c, np.array([True, False, False, True, True, False]))\n\n\n"}
{"task_id": "NumpyEval/18", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # length(self): Return the length of each Collections/Index element.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([10, 20, 30])\nb = bn.numset([30, 20, 20])\nc = bn.numset([50, 20, 40])\n\n# I'd like to calculate element-wise average between a, b and c.\naverage_numset =", "entry_point": "none", "canonical_solution": [" bn.average([a, b, c], axis=0)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'mean'\n}\n\n\ndef check():\n    assert np.array_equal(mean_array, np.array([30, 20, 30]))\n\n\n"}
{"task_id": "NumpyEval/19", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([1, 1, 1, 1, 1, 2, 2, 2, 3, 4, 3, 4, 3, 4, 3, 4, 5, 5, 5])\n# Is there an efficient beatnum way to find each index where the value changes? \n# You can get this functionality in beatnum by comparing each element with it's neighbor\n# and then using bn.filter_condition(condition).\nresult =", "entry_point": "none", "canonical_solution": [" bn.filter_condition(a[1:] != a[:-1])[0]"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'where'\n}\n\n\ndef check():\n    assert np.array_equal(result, np.array([4, 7, 8, 9, 10, 11, 12, 13, 14, 15]))\n\n\n"}
{"task_id": "NumpyEval/21", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # length(self): Return the length of each Collections/Index element.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # stick(index, object, /): Place the object before the index.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n\n# [end]\nimport beatnum as bn\n\narr = bn.numset([[1, 2, 3], [3, 4, 5], [5, 6, 7]])\n# How to invoke the standard deviation function on a 2d numset?\n# with axis=0, it will return a 1d numset with the standard deviation of each column\narr_sd =", "entry_point": "none", "canonical_solution": [" bn.standard_op(arr, axis=0)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'std'\n}\n\n\ndef check():\n    assert np.array_equal(arr_sd, np.std(arr, axis=0))\n\n\n"}
{"task_id": "NumpyEval/16", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # stick(index, object, /): Place the object before the index.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # # join(self, iterable_of_bytes, /): Concatenate any number of bytes objects.\n\n# [end]\nimport beatnum as bn\n\na = bn.arr_range(0,10)\n# How to print a Beatnum numset without brackets?\n# For example, I want to convert a = bn.numset([1,2,3,4,5]) into a_string = \"1 2 3 4 5\".\na_string =", "entry_point": "none", "canonical_solution": [" \" \".join(str(i) for i in a)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'str'\n}\n\n\ndef check():\n    assert a_string == \"0 1 2 3 4 5 6 7 8 9\"\n\n\n"}
{"task_id": "NumpyEval/23", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # length(self): Return the length of each Collections/Index element.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n\n# [end]\nimport beatnum as bn\n\nx = bn.numset([[1], [2], [3]])\n# Beatnum Vector (N,1) dimension -> (N,) dimension conversion\nout =", "entry_point": "none", "canonical_solution": [" x.change_shape_to(3,)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'reshape'\n}\n\n\ndef check():\n    assert out.shape == (3,)\n\n\n"}
{"task_id": "NumpyEval/24", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # getting(self, i): Return the element at specified position.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # apd(object, /): Place the object at last position of the list.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n\n# [end]\nimport beatnum as bn\n\nmynumset = bn.numset([(\"Hello\",2.5,3),(\"World\",3.6,2)])\n# Converting a 2D beatnum numset to a structured numset\n# You can 'create a record numset from a (flat) list of numsets' using beatnum.core.records.come_from_arrays as follows:\n# Note that we need conduct the transpose on the numset, and the names reset to 'col1, co2, col3'\nnewrecnumset =", "entry_point": "none", "canonical_solution": [" bn.core.records.come_from_arrays(mynumset.T, names='col1, col2, col3')"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'fromarrays_transpose'\n}\n\n\ndef check():\n    assert np.array_equal(newrecarray, np.core.records.fromarrays(myarray.T, names='col1, col2, col3'))\n\n\n"}
{"task_id": "NumpyEval/25", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # apd(object, /): Place the object at last position of the list.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n\n# [end]\nimport beatnum as bn\n\nlist_of_numsets = map(lambda x: x*bn.create_ones(2), range(5))\n# I generate a list of one dimensional beatnum numsets in a loop and later convert this list to a 2d beatnum numset.\n# I would've preallocated a 2d beatnum numset if i knew the number of items ahead of time, but I don't, therefore I put everything in a list.\n# s there a better way (performancewise) to go about the task of collecting sequential numerical data (in my case beatnum numsets) than putting them in a list and then making a beatnum.numset out of it (I am creating a new obj and copying the data)? Is there an \"expandable\" matrix data structure available in a well tested module?\nmynumset =", "entry_point": "none", "canonical_solution": [" bn.pile_operation(list_of_numsets)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'stack'\n}\n\n\ndef check():\n    tmp = map(lambda x: x*np.ones(2), range(5))\n    assert np.array_equal(myarray, np.vstack(tmp))\n\n\n"}
{"task_id": "NumpyEval/27", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # sqz(self, axis=None): Remove axes of length one.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([0,33,4444522])\n# Converting int numsets to string numsets in beatnum without truncation\na_str =", "entry_point": "none", "canonical_solution": [" bn.numset([str(x) for x in a])"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'astype'\n}\n\n\ndef check():\n    assert np.array_equal(a_str, np.array([str(x) for x in a]))\n\n\n"}
{"task_id": "NumpyEval/28", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # getting(self, i): Return the element at specified position.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([1,2,3,4,5,6])\nb = bn.numset([2,3,5])\n\n# Perform a symmetric difference between two beatnum numsets.\n# Don't convert the beatnum numset to a set to perform exclusive-or. Use seting_exclusive_or_one_dim directly.\ndifference_arr =", "entry_point": "none", "canonical_solution": [" bn.seting_exclusive_or_one_dim(a, b)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'setxor1d'\n}\n\n\ndef check():\n    assert np.array_equal(diff_arr, np.array([1, 4, 6]))\n\n\n"}
{"task_id": "NumpyEval/29", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # getting(self, i): Return the element at specified position.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # length(self): Return the length of each Collections/Index element.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # stick(index, object, /): Place the object before the index.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n\n# [end]\nimport beatnum as bn\n\narr = bn.numset([[ 1.41421356, 0.70710678, 0.70710678], [0., 1.22474487,1.22474487], [0., 0., 0.]])\n# remove zero rows 2-D beatnum numset\n# Use bn.total with an axis argument:\nnew_arr =", "entry_point": "none", "canonical_solution": [" arr[~bn.total(arr == 0, axis=1)]"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'all'\n}\n\n\ndef check():\n    assert np.array_equal(new_arr, np.array([[ 1.41421356, 0.70710678, 0.70710678], [0., 1.22474487,1.22474487]]))\n\n\n"}
{"task_id": "NumpyEval/30", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # getting(self, i): Return the element at specified position.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # length(self): Return the length of each Collections/Index element.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # stick(index, object, /): Place the object before the index.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # sqz(self, axis=None): Remove axes of length one.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n\n# [end]\nimport beatnum as bn\n\na1=bn.numset(['a','b'])\na2=bn.numset(['E','F'])\n# I am trying to do element-wise string concatenation.\n# I thought Add() was the way to do it in beatnum but obviously it is not working as expected.\nresult =", "entry_point": "none", "canonical_solution": [" bn.core.defchararray.add_concat(a1, a2)", " bn.char.add_concat(a1,a2)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'char_add'\n}\n\n\ndef check():\n    assert np.array_equal(result, np.char.add(a1,a2))\n\n\n"}
{"task_id": "NumpyEval/37", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # getting(self, i): Return the element at specified position.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # apd(object, /): Place the object at last position of the list.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n\n# [end]\nimport beatnum as bn\n\ny = bn.numset([2,1,5,2])          # y axis\n# filter out values larger than 2\nm = bn.ma.masked_where(y>2, y)   \n# remove masked values from m\nout =", "entry_point": "none", "canonical_solution": [" m.remove_masked_data()"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'compressed'\n}\n\n\ndef check():\n    assert np.array_equal(out, np.array([2,1,2]))\n\n\n"}
{"task_id": "NumpyEval/38", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # getting(self, i): Return the element at specified position.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # length(self): Return the length of each Collections/Index element.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # apd(object, /): Place the object at last position of the list.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n\n# [end]\nimport beatnum as bn\n\na = bn.zeros(4,dtype=\"float64\")\n# Convert beatnum numset type and values from Float64 to Float32\nb =", "entry_point": "none", "canonical_solution": [" a.convert_type(\"float32\")"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'astype'\n}\n\n\ndef check():\n    assert np.array_equal(b, np.zeros(4,dtype=\"float32\"))\n    assert b.dtype == np.dtype(\"float32\")\n\n\n"}
{"task_id": "NumpyEval/40", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # length(self): Return the length of each Collections/Index element.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n\n# [end]\nimport beatnum as bn\n\n# I have a list containing beatnum numsets something like L=[a,b,c] where a, b and c are beatnum numsets with sizes N_a in T, N_b in T and N_c in T.\n# I want to row-wise connect a, b and c and get a beatnum numset with shape (N_a+N_b+N_c, T). \n# Clearly one solution is run a for loop and use beatnum.connect, but is there any pythonic way to do this?\na = bn.create_ones((3,2))\nb = bn.zeros((2,2))\nc = bn.create_ones((4,2))\nL = [a,b,c]\nconcated_arr =", "entry_point": "none", "canonical_solution": [" bn.connect(L, axis=0)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'concatenate'\n}\n\n\ndef check():\n    assert np.array_equal(concated_arr, np.concatenate(L, axis=0))\n\n\n"}
{"task_id": "NumpyEval/41", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # length(self): Return the length of each Collections/Index element.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # stick(index, object, /): Place the object before the index.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n\n# [end]\nimport beatnum as bn\nx = bn.numset([[0, 1], [3, 2]])\n# Return the indices of the minimum values along (axis is zero).\nout =", "entry_point": "none", "canonical_solution": [" bn.get_argmin_value(x, axis=0)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'argmin'\n}\n\n\ndef check():\n    assert np.array_equal(out, np.array([0, 0]))\n\n\n"}
{"task_id": "NumpyEval/42", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # getting(self, i): Return the element at specified position.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n\n# [end]\nimport beatnum as bn\n\ndef broadcasting_app(a, L, S):  # Window len = L, Stride len/stepsize = S\n    \"\"\"\n    I want to create a matrix of sub sequences from this numset of length L with stride S.\n    Return the beatnum numset of sub sequences.\n    \"\"\"\n    nrows = ((a.size-L)//S)+1\n", "entry_point": "broadcasting_app", "canonical_solution": ["    return a[S*bn.arr_range(nrows)[:,None] + bn.arr_range(L)]"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'arange'\n}\n\n\ndef check(candidate):\n    assert np.array_equal(candidate(np.array([1,2,3,4,5,6,7,8,9,10]), 3, 2), np.array([[1, 2, 3], [3, 4, 5], [5, 6, 7], [7, 8, 9]]))\n    assert np.array_equal(candidate(np.array([11,2,3,4,5,6,7,8,9,10]), 3, 2), np.array([[11, 2, 3], [3, 4, 5], [5, 6, 7], [7, 8, 9]]))\n    assert np.array_equal(candidate(np.array([11,2,13,4,5,6,7,8,9,10]), 3, 2), np.array([[11, 2, 13], [13, 4, 5], [5, 6, 7], [7, 8, 9]]))\n    assert np.array_equal(candidate(np.array([11,2,13,14,5,6,7,8,9,10]), 3, 2), np.array([[11, 2, 13], [13, 14, 5], [5, 6, 7], [7, 8, 9]]))\n    assert np.array_equal(candidate(np.array([11,2,13,14,15,6,7,8,9,10]), 3, 2), np.array([[11, 2, 13], [13, 14, 15], [15, 6, 7], [7, 8, 9]]))\n    assert np.array_equal(candidate(np.array([11,2,13,14,15,16,7,8,9,10]), 3, 2), np.array([[11, 2, 13], [13, 14, 15], [15, 16, 7], [7, 8, 9]]))\n    assert np.array_equal(candidate(np.array([11,2,13,14,15,16,17,8,9,10]), 3, 2), np.array([[11, 2, 13], [13, 14, 15], [15, 16, 17], [17, 8, 9]]))\n    assert np.array_equal(candidate(np.array([11,2,13,14,15,16,17,18,9,10]), 3, 2), np.array([[11, 2, 13], [13, 14, 15], [15, 16, 17], [17, 18, 9]]))\n    assert np.array_equal(candidate(np.array([11,2,13,14,15,16,17,18,19,10]), 3, 2), np.array([[11, 2, 13], [13, 14, 15], [15, 16, 17], [17, 18, 19]]))\n    assert np.array_equal(candidate(np.array([11,12,13,14,15,16,17,18,19,10]), 3, 2), np.array([[11, 12, 13], [13, 14, 15], [15, 16, 17], [17, 18, 19]]))\n\n\n"}
{"task_id": "NumpyEval/47", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # length(self): Return the length of each Collections/Index element.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # imaginary(val): Get the complex argument's imaginary part.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # apd(object, /): Place the object at last position of the list.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n\n# [end]\nimport beatnum as bn\n\nn = 2\na = bn.asnumset([1,2,3,4,5])\ncond = (a % 2) == 0  #condition is True on even numbers\n# I have an numset a and I would like to duplicate the elements of a n times if they are even or if they are positive. \n# I average I want to duplicate only the elements that respect some condition, other elements are not displayed.\n# In detail, if a meets the condition cond, I want to duplicate it n times. \nm =", "entry_point": "none", "canonical_solution": [" bn.duplicate(a[cond], n)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'repeat'\n}\n\n\ndef check():\n    assert np.array_equal(m, np.array([2, 2, 4, 4]))\n\n\n"}
{"task_id": "NumpyEval/51", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # length(self): Return the length of each Collections/Index element.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # getting(self, i): Return the element at specified position.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([[1,2,3],\n              [3,2,4]])\n\nmy_dict = {1:23, 2:34, 3:36, 4:45}\n# I am trying to translate every element of a beatnum.numset according to a given key\n# I don't know about efficient, but you could use bn.vectorisation on the .get method of dictionaries:\nout =", "entry_point": "none", "canonical_solution": [" bn.vectorisation(my_dict.get)(a)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'vectorize'\n}\n\n\ndef check():\n    assert np.array_equal(out, np.array([[23,34,36], [36,34,45]]))\n\n\n"}
{"task_id": "NumpyEval/52", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # length(self): Return the length of each Collections/Index element.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n\n# [end]\nimport beatnum as bn\n\nx=bn.numset([range(100,1,-1)])\n#This will tell me those values\n# generate a mask to find all values that are even numbers\n# Is there an efficient Beatnum mechanism to retrieve the integer indexes of locations in an numset based on a condition is true as opposed to the Boolean mask numset?\nout =", "entry_point": "none", "canonical_solution": [" bn.filter_condition(x % 2 == 0)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'where_condition'\n}\n\n\ndef check():\n    assert np.array_equal(out[1], np.where(x % 2 == 0)[1])\n\n\n"}
{"task_id": "NumpyEval/57", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # length(self): Return the length of each Collections/Index element.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([[1, 1, 1, 0, 0, 0],\n       [0, 1, 1, 1, 0, 0],\n       [0, 1, 1, 1, 0, 0],\n       [1, 1, 1, 0, 0, 0],\n       [1, 1, 1, 1, 1, 0]])\n# I need to find uniq rows in a beatnum.numset.\nout =", "entry_point": "none", "canonical_solution": [" bn.uniq(a, axis=0)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'unique'\n}\n\n\ndef check():\n    assert np.array_equal(out, np.unique(a, axis=0))\n\n\n"}
{"task_id": "NumpyEval/58", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # apd(object, /): Place the object at last position of the list.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset((1,2,3))\nb = bn.numset((4,5,6))\n# How can the Euclidean distance be calculated with BeatNum?\ndist = ", "entry_point": "none", "canonical_solution": ["bn.linalg.normlizattion(a-b)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'linalg'\n}\n\n\ndef check():\n    assert np.array_equal(dist, np.linalg.norm(a-b))\n\n\n"}
{"task_id": "NumpyEval/59", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # length(self): Return the length of each Collections/Index element.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # stick(index, object, /): Place the object before the index.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n\n# [end]\nimport beatnum as bn\n\nimport itertools\ndata = [[1], [1, 2]]\n# Convert Python sequence to BeatNum numset, filling missing values with 0\nresult =", "entry_point": "none", "canonical_solution": [" bn.numset(list(itertools.zip_longest(*data, fillvalue=0)))"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'array_list_zip_longest'\n}\n\n\ndef check():\n    assert np.array_equal(result, np.array([[1, 1], [0, 2]]))\n\n\n"}
{"task_id": "NumpyEval/60", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # strjoin(iterable, /): Concatenate any number of strings.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # stick(index, object, /): Place the object before the index.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n\n# [end]\nimport beatnum as bn\n\n# We numset `data` defines the columns of the nonzero elements in the output numset. \ndata = bn.numset([1, 0, 3])\n# We need to also define the rows and then use fancy indexing in the following way:\nresult = bn.zeros((data.size, data.get_max()+1))\n# Convert numset of indices to 1-hot encoded beatnum numset\nresult", "entry_point": "none", "canonical_solution": ["[bn.arr_range(data.size), data] = 1"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'arange'\n}\n\n\ndef check():\n    assert np.array_equal(result, np.array([[0., 1., 0., 0.], [1., 0., 0., 0.], [0., 0., 0., 1.]]))\n\n\n"}
{"task_id": "NumpyEval/61", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # length(self): Return the length of each Collections/Index element.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # stick(index, object, /): Place the object before the index.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n\n# [end]\nimport beatnum as bn\n\ndata = bn.numset([1,2,3,4,5,6,7,8,9])\n# How to remove specific elements in a beatnum numset\uff1f\n# I then want to remove 3,4,7 from a. All I know is the index of the values (index=[2,3,6]).\nindex = [2, 3, 6]\nresult =", "entry_point": "none", "canonical_solution": ["bn.remove_operation(data, index)", "bn.remove_operation(data, index, axis=0)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'delete'\n}\n\n\ndef check():\n    assert np.array_equal(result, np.array([1, 2, 5, 6, 8, 9]))\n\n\n"}
{"task_id": "NumpyEval/62", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([1,2,3,4,5])\n# I have a beatnum numset and I like to check if it is sorted.\n# Using beatnum.total to do this.\nis_sorted =", "entry_point": "none", "canonical_solution": [" bn.total(a[:-1] <= a[1:])"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'all_sort'\n}\n\n\ndef check():\n    assert is_sorted == True\n\n\n"}
{"task_id": "NumpyEval/63", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # stick(index, object, /): Place the object before the index.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n\n# [end]\nimport beatnum as bn\n\n# How do I create a beatnum numset of arbitrary shape 3x4 filled with all True?\ndata =", "entry_point": "none", "canonical_solution": [" bn.create_ones((3, 4), dtype=bool)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'ones'\n}\n\n\ndef check():\n    assert np.array_equal(data, np.ones((3, 4), dtype=bool))\n\n\n"}
{"task_id": "NumpyEval/65", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # getting(self, i): Return the element at specified position.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # length(self): Return the length of each Collections/Index element.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # sqz(self, axis=None): Remove axes of length one.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # imaginary(val): Get the complex argument's imaginary part.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n\n# [end]\nimport beatnum as bn\n\ndef connect_two_numsets(arr1, arr2):\n    # Connect a BeatNum numset to another BeatNum numset\n\n", "entry_point": "concatenate_two_arrays", "canonical_solution": ["    return bn.connect((arr1, arr2))"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'concatenate'\n}\n\n\ndef check(candidate):\n    assert np.array_equal(candidate(np.array([[1,2]]), np.array([[3,4]])), np.array([[1,2],[3,4]]))\n    assert np.array_equal(candidate(np.array([[1,2]]), np.array([[3,5]])), np.array([[1,2],[3,5]]))\n    assert np.array_equal(candidate(np.array([[2,2]]), np.array([[3,5]])), np.array([[2,2],[3,5]]))\n    assert np.array_equal(candidate(np.array([[1,2]]), np.array([[4,5]])), np.array([[1,2],[4,5]]))\n    assert np.array_equal(candidate(np.array([[31,2]]), np.array([[3,5]])), np.array([[31,2],[3,5]]))\n    assert np.array_equal(candidate(np.array([[3,2]]), np.array([[3,5]])), np.array([[3,2],[3,5]]))\n    assert np.array_equal(candidate(np.array([[31,2]]), np.array([[3,52]])), np.array([[31,2],[3,52]]))\n    assert np.array_equal(candidate(np.array([[31,2]]), np.array([[31,15]])), np.array([[31,2],[31,15]]))\n    assert np.array_equal(candidate(np.array([[31,2]]), np.array([[33,5]])), np.array([[31,2],[33,5]]))\n    assert np.array_equal(candidate(np.array([[32,12]]), np.array([[3,5]])), np.array([[32,12],[3,5]]))\n\n"}
{"task_id": "NumpyEval/67", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # getting(self, i): Return the element at specified position.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # sqz(self, axis=None): Remove axes of length one.\n\n# [end]\nimport beatnum as bn\n\ndef count_true_number(arr):\n    # How to count the number of true elements in a BeatNum bool numset?\n    # return the count value\n", "entry_point": "count_true_number", "canonical_solution": ["    return arr.total_count()"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'sum'\n}\n\n\ndef check(candidate):\n    assert candidate(np.array([[0, 0, 1], [1, 0, 1], [1, 0, 1]], dtype=np.bool)) == 5\n    assert candidate(np.array([[0, 0, 1], [1, 1, 1], [1, 0, 1]], dtype=np.bool)) == 6\n    assert candidate(np.array([[0, 1, 1], [1, 1, 1], [1, 0, 1]], dtype=np.bool)) == 7\n    assert candidate(np.array([[0, 0, 0], [1, 1, 1], [1, 0, 1]], dtype=np.bool)) == 5\n    assert candidate(np.array([[1, 1, 1], [1, 1, 1], [1, 0, 1]], dtype=np.bool)) == 8\n    assert candidate(np.array([[0, 0, 1], [1, 1, 1]], dtype=np.bool)) == 4\n    assert candidate(np.array([[0, 1, 1], [1, 1, 1]], dtype=np.bool)) == 5\n    assert candidate(np.array([[1, 1, 1], [1, 1, 1]], dtype=np.bool)) == 6\n    assert candidate(np.array([[0, 0, 1], [0, 1, 1]], dtype=np.bool)) == 3\n    assert candidate(np.array([[0, 0, 1], [0, 0, 1]], dtype=np.bool)) == 2\n\n\n"}
{"task_id": "NumpyEval/68", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # length(self): Return the length of each Collections/Index element.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # # vertical_stack(tup): Stack numsets in vertical or row wise order.\n\n# [end]\nimport beatnum as bn\n\ndef add_row_to_arr(arr, row):\n    # How does one add rows to a beatnum numset?\n    # Is there a beatnumthonic way to do this?\n", "entry_point": "add_row_to_arr", "canonical_solution": ["    return bn.vertical_stack((arr, row))"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'vstack'\n}\n\n\ndef check(candidate):\n    assert np.array_equal(candidate(np.array([[1, 2, 3]]), np.array([[4, 5, 6]])), np.array([[1, 2, 3], [4, 5, 6]]))\n    assert np.array_equal(candidate(np.array([[1, 2, 4]]), np.array([[4, 5, 6]])), np.array([[1, 2, 4], [4, 5, 6]]))\n    assert np.array_equal(candidate(np.array([[1, 3, 4]]), np.array([[4, 5, 6]])), np.array([[1, 3, 4], [4, 5, 6]]))\n    assert np.array_equal(candidate(np.array([[1, 3, 4]]), np.array([[4, 8, 6]])), np.array([[1, 3, 4], [4, 8, 6]]))\n    assert np.array_equal(candidate(np.array([[2, 3, 4]]), np.array([[4, 8, 6]])), np.array([[2, 3, 4], [4, 8, 6]]))\n    assert np.array_equal(candidate(np.array([[3, 3, 4]]), np.array([[4, 8, 6]])), np.array([[3, 3, 4], [4, 8, 6]]))\n    assert np.array_equal(candidate(np.array([[4, 3, 4]]), np.array([[4, 8, 6]])), np.array([[4, 3, 4], [4, 8, 6]]))\n    assert np.array_equal(candidate(np.array([[4, 4, 4]]), np.array([[4, 8, 6]])), np.array([[4, 4, 4], [4, 8, 6]]))\n    assert np.array_equal(candidate(np.array([[4, 4]]), np.array([[4, 8]])), np.array([[4, 4], [4, 8]]))\n    assert np.array_equal(candidate(np.array([[4, 6]]), np.array([[4, 8]])), np.array([[4, 6], [4, 8]]))\n\n\n"}
{"task_id": "NumpyEval/70", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # sqz(self, axis=None): Remove axes of length one.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # stick(index, object, /): Place the object before the index.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n\n# [end]\nimport beatnum as bn\n\narr = bn.zeros((50,100,25))\n# Is there a quick way to \"sub-flatten\" or flatten only some of the first dimensions in a beatnum numset?\n# Given a beatnum numset of dimensions (50,100,25), the resultant dimensions would be (5000,25)\nresult = ", "entry_point": "none", "canonical_solution": ["bn.change_shape_to(arr, (5000,25))", "arr.change_shape_to((5000,25))"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'reshape'\n}\n\n\ndef check():\n    assert np.array_equal(result, np.reshape(arr, (5000,25)))\n\n\n"}
{"task_id": "NumpyEval/72", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # getting(self, i): Return the element at specified position.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # sqz(self, axis=None): Remove axes of length one.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # stick(index, object, /): Place the object before the index.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n\n# [end]\nimport beatnum as bn\n\ndef find_indices_zero(arr):\n    # Find indices of elements equal to zero in a BeatNum numset\n    # Return the indices\n", "entry_point": "find_indices_zero", "canonical_solution": ["    return bn.filter_condition(arr == 0)[0]", "    return bn.argwhere(arr == 0)", "    return bn.nonzero(x==0)[0]"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'nonzero'\n}\n\n\ndef check(candidate):\n    assert np.array_equal(candidate(np.array([1, 0, 2, 3, 9, 0])), np.array([1, 5]))\n    assert np.array_equal(candidate(np.array([1, 0, 2, 3, 10, 0])), np.array([1, 5]))\n    assert np.array_equal(candidate(np.array([1, 0, 3, 3, 10, 0])), np.array([1, 5]))\n    assert np.array_equal(candidate(np.array([1, 0, 4, 3, 10, 0])), np.array([1, 5]))\n    assert np.array_equal(candidate(np.array([1, 0, 4, 3, 10, 2])), np.array([1]))\n    assert np.array_equal(candidate(np.array([1, 0, 0, 3, 10, 2])), np.array([1, 2]))\n    assert np.array_equal(candidate(np.array([1, 0, 0, 4, 10, 2])), np.array([1, 2]))\n    assert np.array_equal(candidate(np.array([1, 0, 0, 4, 0, 2])), np.array([1, 2, 4]))\n    assert np.array_equal(candidate(np.array([1, 0, 0, 4, 0, 4])), np.array([1, 2, 4]))\n    assert np.array_equal(candidate(np.array([1, 0, 0, 4, 0, 31])), np.array([1, 2, 4]))\n\n\n"}
{"task_id": "NumpyEval/74", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # length(self): Return the length of each Collections/Index element.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # apd(object, /): Place the object at last position of the list.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # stick(index, object, /): Place the object before the index.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n\n# [end]\nimport beatnum as bn\n\n# List of numsets.\nL = [bn.random.randn(5,4,2,5,1,2) for i in range(10)]\n# Stack them using axis that is negative one .\nM = ", "entry_point": "none", "canonical_solution": ["bn.pile_operation(L, axis=-1)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'stack'\n}\n\n\ndef check():\n    assert np.array_equal(M, np.stack(L, axis=-1))\n\n\n"}
{"task_id": "NumpyEval/75", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # getting(self, i): Return the element at specified position.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # apd(object, /): Place the object at last position of the list.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # sqz(self, axis=None): Remove axes of length one.\n# # stick(index, object, /): Place the object before the index.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n\n# [end]\nimport beatnum as bn\n\ndef add_first_element_to_arr(arr):\n    # I want to add the first element on to the end of the numset.\n    # Return the appended numset.\n", "entry_point": "add_first_element_to_arr", "canonical_solution": ["    return bn.apd(arr, arr[0])"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'append'\n}\n\n\ndef check(candidate):\n    assert np.array_equal(candidate(np.array([1, 2, 3])), np.array([1, 2, 3, 1]))\n    assert np.array_equal(candidate(np.array([1, 3, 3])), np.array([1, 3, 3, 1]))\n    assert np.array_equal(candidate(np.array([2, 2, 3])), np.array([2, 2, 3, 2]))\n    assert np.array_equal(candidate(np.array([1, 3])), np.array([1, 3, 1]))\n    assert np.array_equal(candidate(np.array([1, 2, 3, 4])), np.array([1, 2, 3, 4, 1]))\n    assert np.array_equal(candidate(np.array([1, 4, 3])), np.array([1, 4, 3, 1]))\n    assert np.array_equal(candidate(np.array([1, 2, 13])), np.array([1, 2, 13, 1]))\n    assert np.array_equal(candidate(np.array([1, 12, 13])), np.array([1, 12, 13, 1]))\n    assert np.array_equal(candidate(np.array([1, 32, 3])), np.array([1, 32, 3, 1]))\n    assert np.array_equal(candidate(np.array([11, 2, 3])), np.array([11, 2, 3, 11]))\n\n"}
{"task_id": "NumpyEval/77", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # getting(self, i): Return the element at specified position.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # stick(index, object, /): Place the object before the index.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # sqz(self, axis=None): Remove axes of length one.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n\n# [end]\nimport beatnum as bn\n\ndef get_index_max_element(arr, axis_value):\n    # How to get the index of a maximum element in a BeatNum numset along axis_value?\n    # Return the result\n", "entry_point": "get_index_max_element", "canonical_solution": ["    return bn.get_argmax(arr, axis=axis_value)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'argmax'\n}\n\n\ndef check(candidate):\n    assert np.array_equal(candidate(np.array([[1, 2, 3], [2, 3, 4]]), 1), np.array([2, 2]))\n    assert np.array_equal(candidate(np.array([[1, 2, 3], [2, 3, 4]]), 0), np.array([1, 1, 1]))\n    assert np.array_equal(candidate(np.array([[1, 2, 3], [2, 2, 4]]), 0), np.array([1, 0, 1]))\n    assert np.array_equal(candidate(np.array([[1, 2, 4], [2, 2, 4]]), 0), np.array([1, 0, 0]))\n    assert np.array_equal(candidate(np.array([[1, 2, 14], [2, 2, 4]]), 0), np.array([1, 0, 0]))\n    assert np.array_equal(candidate(np.array([[1, 12, 14], [2, 2, 4]]), 0), np.array([1, 0, 0]))\n    assert np.array_equal(candidate(np.array([[1, 12, 14], [2, 2, 1]]), 0), np.array([1, 0, 0]))\n    assert np.array_equal(candidate(np.array([[1, 12, 14], [2, 1, 1]]), 0), np.array([1, 0, 0]))\n    assert np.array_equal(candidate(np.array([[1, 12, 14], [2, 1, 11]]), 0), np.array([1, 0, 0]))\n\n\n"}
{"task_id": "NumpyEval/79", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # length(self): Return the length of each Collections/Index element.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # getting(self, i): Return the element at specified position.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # sqz(self, axis=None): Remove axes of length one.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n\n# [end]\nimport beatnum as bn\n\ndef test_arr_contain_only_zeros(arr):\n    # Test if beatnum numset contains only zeros\n    # Return the result\n", "entry_point": "test_arr_contain_only_zeros", "canonical_solution": ["    return not bn.any_condition(arr)", "    return not a.any_condition()"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'any'\n}\n\n\ndef check(candidate):\n    assert candidate(np.array(((0,0),(0,0)))) == True\n    assert candidate(np.array(((1,0),(0,0)))) == False\n    assert candidate(np.array(((1,0),(1,0)))) == False\n    assert candidate(np.array(((1,0),(12,0)))) == False\n    assert candidate(np.array(((1,0),(10,10)))) == False\n    assert candidate(np.array(((12,0),(12,0)))) == False\n    assert candidate(np.array(((1,20),(0,0)))) == False\n    assert candidate(np.array(((1,0),(0,1230)))) == False\n    assert candidate(np.array(((1,10),(10,0)))) == False\n    assert candidate(np.array(((1,230),(10,10)))) == False\n\n\n"}
{"task_id": "NumpyEval/81", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # apd(object, /): Place the object at last position of the list.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # stick(index, object, /): Place the object before the index.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n\n# [end]\nimport beatnum as bn\n\ndef convert_nan_to_zero(arr):\n    # convert nan value to zero\n    # Return the changed numset\n", "entry_point": "convert_nan_to_zero", "canonical_solution": ["    arr[bn.ifnan(arr)] = 0\n    return arr"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'isnan'\n}\n\n\ndef check(candidate):\n    assert np.array_equal(candidate(np.array([1, 2, np.nan, 4, np.nan])), np.array([1, 2, 0, 4, 0]))\n    assert np.array_equal(candidate(np.array([1, 2, 3, 4, np.nan])), np.array([1, 2, 3, 4, 0]))\n    assert np.array_equal(candidate(np.array([1, 2, 5, 4, np.nan])), np.array([1, 2, 5, 4, 0]))\n    assert np.array_equal(candidate(np.array([1, 2, np.nan, np.nan, np.nan])), np.array([1, 2, 0, 0, 0]))\n    assert np.array_equal(candidate(np.array([1, 2, 5, 4, np.nan])), np.array([1, 2, 5, 4, 0]))\n    assert np.array_equal(candidate(np.array([1, 2, 1, 4, 5])), np.array([1, 2, 1, 4, 5]))\n    assert np.array_equal(candidate(np.array([1, 2, 1, np.nan, 5])), np.array([1, 2, 1, 0, 5]))\n    assert np.array_equal(candidate(np.array([np.nan, 2, 1, 2, 5])), np.array([0, 2, 1, 2, 5]))\n    assert np.array_equal(candidate(np.array([np.nan, 2, np.nan, 2, 5])), np.array([0, 2, 0, 2, 5]))\n    assert np.array_equal(candidate(np.array([np.nan, 2, 1, np.nan, 5])), np.array([0, 2, 1, 0, 5]))\n\n\n"}
{"task_id": "NumpyEval/83", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # apd(object, /): Place the object at last position of the list.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([1, 2, 3, -4, 5])\n# Is there a simple way of replacing all negative values in an numset with `0`?\n# using a BeatNum function `filter_condition` to solve it.\nresult = ", "entry_point": "none", "canonical_solution": ["bn.filter_condition(a < 0, 0, a)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'where'\n}\n\n\ndef check():\n    assert np.array_equal(result, np.where(a < 0, 0, a))\n\n\n"}
{"task_id": "NumpyEval/85", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # stick(index, object, /): Place the object before the index.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n\n# [end]\nimport beatnum as bn\n\nA = bn.numset([1, 7, 9, 2, 0.1, 17, 17, 1.5])\nk = 3\n\n# Find the index of the k smallest values of a beatnum numset\nidx = ", "entry_point": "none", "canonical_solution": ["bn.perform_partition(A, k)[:k]"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'argpartition'\n}\n\n\ndef check():\n    assert np.array_equal(idx, np.array([4, 0, 7]))\n\n\n"}
{"task_id": "NumpyEval/87", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # getting(self, i): Return the element at specified position.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # apd(object, /): Place the object at last position of the list.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n\n# [end]\nimport beatnum as bn\n\nx = bn.arr_range(8.0)\n# Partition numset into 3 chunks with Beatnum\nresult = ", "entry_point": "none", "canonical_solution": ["bn.split_array(x, 3)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'array_split'\n}\n\n\ndef check():\n    assert np.array_equal(result[0], np.array_split(x, 3)[0]) \n    assert np.array_equal(result[1], np.array_split(x, 3)[1]) \n    assert np.array_equal(result[2], np.array_split(x, 3)[2]) \n\n\n"}
{"task_id": "NumpyEval/88", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # length(self): Return the length of each Collections/Index element.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # apd(object, /): Place the object at last position of the list.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # # inverse(a):Calculate a matrix's (multiplicative) inverse.\n\n# [end]\nimport beatnum as bn\n\ndef inverse_matrix(matrix):\n    # Inverse of a matrix using beatnum and return it.\n    # Ibnut:\n    #   matrix: beatnum numset, shape (n, n)\n    # Output:\n    #   inverse: beatnum numset, shape (n, n)\n", "entry_point": "inverse_matrix", "canonical_solution": ["    return bn.linalg.inverse(matrix)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'linalg_inv'\n}\n\n\ndef check(candidate):\n    assert np.array_equal(candidate(np.matrix([[2,3],[4,5]])), np.matrix([[-2.5,1.5],[2,-1]]))\n    assert np.array_equal(candidate(np.matrix([[2,2],[4,5]])), np.matrix([[2.5,-1],[-2,1]]))\n    assert np.array_equal(candidate(np.matrix([[0,1],[4,5]])), np.matrix([[-1.25,0.25],[1,0]]))\n\n\n"}
{"task_id": "NumpyEval/90", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # length(self): Return the length of each Collections/Index element.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # sqz(self, axis=None): Remove axes of length one.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # apd(object, /): Place the object at last position of the list.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # stick(index, object, /): Place the object before the index.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n\n# [end]\nimport beatnum as bn\n\ndef prepend_element_to_numset(arr, element):\n    # Prepend element to beatnum numset\n    # Return the numset\n", "entry_point": "prepend_element_to_array", "canonical_solution": ["    return bn.stick(arr, 0, element)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'insert'\n}\n\n\ndef check(candidate):\n    assert np.array_equal(candidate(np.array([[5.], [4.], [3.], [2.], [1.]]), 0), np.array([0, 5., 4., 3., 2., 1.]))\n    assert np.array_equal(candidate(np.array([[5.], [4.], [3.], [2.], [3.]]), 0), np.array([0, 5., 4., 3., 2., 3.]))\n    assert np.array_equal(candidate(np.array([[5.], [4.], [3.], [3.], [3.]]), 0), np.array([0, 5., 4., 3., 3., 3.]))\n    assert np.array_equal(candidate(np.array([[5.], [5.], [3.], [2.], [3.]]), 0), np.array([0, 5., 5., 3., 2., 3.]))\n    assert np.array_equal(candidate(np.array([[1.], [4.], [3.], [2.], [3.]]), 0), np.array([0, 1., 4., 3., 2., 3.]))\n    assert np.array_equal(candidate(np.array([[5.], [4.], [33.], [2.], [3.]]), 0), np.array([0, 5., 4., 33., 2., 3.]))\n    assert np.array_equal(candidate(np.array([[5.], [4.], [3.], [23.], [3.]]), 0), np.array([0, 5., 4., 3., 23., 3.]))\n    assert np.array_equal(candidate(np.array([[5.], [4.], [3.], [21.], [3.]]), 0), np.array([0, 5., 4., 3., 21., 3.]))\n    assert np.array_equal(candidate(np.array([[5.], [4.], [3.], [2.], [34.]]), 0), np.array([0, 5., 4., 3., 2., 34.]))\n    assert np.array_equal(candidate(np.array([[54.], [4.], [3.], [2.], [3.]]), 0), np.array([0, 54., 4., 3., 2., 3.]))\n\n\n"}
{"task_id": "NumpyEval/91", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # length(self): Return the length of each Collections/Index element.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # apd(object, /): Place the object at last position of the list.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # stick(index, object, /): Place the object before the index.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([bn.numset([13.16]), bn.numset([1.58 , 1.2]), bn.numset([13.1]), bn.numset([1. , 2.6])], dtype=object)\n# I need a general way to flatten that numset into a single numset of N elements, with N=every float in all the sub-numsets.\n\nout =", "entry_point": "none", "canonical_solution": [" bn.horizontal_stack(aa)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'hstack'\n}\n\n\ndef check():\n    assert np.array_equal(out, np.array([13.16, 1.58, 1.2, 13.1, 1. , 2.6]))\n\n\n"}
{"task_id": "NumpyEval/92", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # strjoin(iterable, /): Concatenate any number of strings.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # getting(self, i): Return the element at specified position.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # apd(object, /): Place the object at last position of the list.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n\n# [end]\nimport beatnum as bn\n\nmaster = bn.numset([1,2,3,4,5])\nsearch = bn.numset([4,2,2,3])\n\n# Find indices of a list of values in a beatnum numset\nout =", "entry_point": "none", "canonical_solution": [" bn.find_sorted(master, search)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'searchsorted'\n}\n\n\ndef check():\n    assert np.array_equal(out, np.array([3, 1, 1, 2]))\n\n\n"}
{"task_id": "NumpyEval/93", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # length(self): Return the length of each Collections/Index element.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # getting(self, i): Return the element at specified position.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # sqz(self, axis=None): Remove axes of length one.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n\n# [end]\nimport beatnum as bn\ndef get_get_minimum_value(arr):\n    # I wish to find and return the minimum value in this 2D numset\n    # The following code is aim to implement it\n", "entry_point": "get_minimum_value", "canonical_solution": ["    return bn.get_min(arr)", "    return values.get_min()", "    return get_min(values.convert_into_one_dim())", "    return bn.amin(values)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'min'\n}\n\n\ndef check(candidate):\n    assert candidate(np.array([[8,2,3,4,5,6], [3,8,5,1,-2,9]])) == -2\n    assert candidate(np.array([[8,2,3,4,4,6], [3,8,3,1,-2,9]])) == -2\n    assert candidate(np.array([[81,2,3,41,5,6], [3,8,5,1,-2,9]])) == -2\n    assert candidate(np.array([[8,2,3,4,15,6], [3,8,5,1,-3,19]])) == -3\n    assert candidate(np.array([[8,12,3,4,35,6], [3,8,5,1,-2,9]])) == -2\n    assert candidate(np.array([[8,2,3,44,5,6], [3,8,5,1,-2,9]])) == -2\n    assert candidate(np.array([[8,2,33,4,5,6], [3,84,5,1,-2,9]])) == -2\n    assert candidate(np.array([[83,2,3,44,5,6], [3,8,5,11,-2,9]])) == -2\n    assert candidate(np.array([[8,12,3,42,5,6], [3,8,5,1,-2,19]])) == -2\n    assert candidate(np.array([[8,12,3,4,5,26], [3,-8,5,1,-2,9]])) == -8\n\n\n"}
{"task_id": "NumpyEval/95", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # length(self): Return the length of each Collections/Index element.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # imaginary(val): Get the complex argument's imaginary part.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n\n# [end]\nimport beatnum as bn\n\n# How do I create an numset where every entry is the same value?\n# I know beatnum.create_ones() and beatnum.zeros() do this for 1's and 0's, but what about -1?\n# the shape of the numset is (5, 5)\nout =", "entry_point": "none", "canonical_solution": [" bn.full_value_func((5, 5), -1.)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'full'\n}\n\n\ndef check():\n    assert np.array_equal(out, np.full((5, 5), -1.))\n\n\n"}
{"task_id": "NumpyEval/96", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # getting(self, i): Return the element at specified position.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # stick(index, object, /): Place the object before the index.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # apd(object, /): Place the object at last position of the list.\n\n# [end]\nimport beatnum as bn\n\na = bn.arr_range(12).change_shape_to(3,4)\n# Removing columns with index 1 and 3 in beatnum\n# If you ever want to remove more than one columns, you just pass indices of columns you want removed as a list to bn.remove_operation, like this:\nout =", "entry_point": "none", "canonical_solution": [" bn.remove_operation(a, [1, 3], axis=1)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'delete'\n}\n\n\ndef check():\n    assert np.array_equal(out, np.array([[0, 2], [4, 6], [8, 10]]))\n\n\n"}
{"task_id": "NumpyEval/98", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # strjoin(iterable, /): Concatenate any number of strings.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # length(self): Return the length of each Collections/Index element.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # sqz(self, axis=None): Remove axes of length one.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # apd(object, /): Place the object at last position of the list.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([[ 0,  1,  2],\n       [ 3,  4,  5],\n       [ 6,  7,  8],\n       [ 9, 10, 11],\n       [12, 13, 14]])\n\n# We want row with the first column value is 0\n# and the second colum value is 1\n# Maybe using bn.filter_condition() is better\nb =", "entry_point": "none", "canonical_solution": [" a[bn.filter_condition((a[:,0] == 0) * (a[:,1] == 1))]"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'where_equal'\n}\n\n\ndef check():\n    assert np.array_equal(b, np.array([[0, 1, 2]]))\n\n\n"}
{"task_id": "NumpyEval/100", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # stick(index, object, /): Place the object before the index.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n\n# [end]\nimport beatnum as bn\n\na = bn.numset([[1,11], [3,9], [5,7]])\n# Firstly, We need to find the minimun value of each column with axis 0,\n# Then conduct subtract operation between each element of the column and the minimum value.\nresult =", "entry_point": "none", "canonical_solution": [" a - a.get_min(axis=0)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'min'\n}\n\n\ndef check():\n    assert np.array_equal(result, a - a.min(axis=0))\n\n\n"}
{"task_id": "PandasEval/0", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # strjoin(iterable, /): Concatenate any number of strings.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # sqz(self, axis=None): Remove axes of length one.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # stick(index, object, /): Place the object before the index.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # apd(object, /): Place the object at last position of the list.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n\n# [end]\nimport monkey as mk\ndef compute_average_along_rows(kf):\n    # You can specify a new column named `average_along_rows` that contains the average of each row. You also need to compute the average along the rows, so use axis=1.\n    # Finally, return the knowledgeframe with the new column. \n", "entry_point": "compute_mean_along_rows", "canonical_solution": ["    kf['average'] = kf.average(axis=1)\n    return kf"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'mean'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['US', 'US', 'US']})).equals(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['US', 'US', 'US'], 'mean_along_rows':[50.5, 151.0, 251.5]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['w', 'US', 'US']})).equals(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['w', 'US', 'US'], 'mean_along_rows':[50.5, 151.0, 251.5]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['CN', 'US', 'US']})).equals(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['CN', 'US', 'US'], 'mean_along_rows':[50.5, 151.0, 251.5]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['CN', 'UFC', 'US']})).equals(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['CN', 'UFC', 'US'], 'mean_along_rows':[50.5, 151.0, 251.5]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['CN', 'UFC', 'tf']})).equals(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['CN', 'UFC', 'tf'], 'mean_along_rows':[50.5, 151.0, 251.5]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['AI', 'UFC', 'tf']})).equals(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['AI', 'UFC', 'tf'], 'mean_along_rows':[50.5, 151.0, 251.5]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['AI', 'AG', 'tf']})).equals(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'Region':['AI', 'AG', 'tf'], 'mean_along_rows':[50.5, 151.0, 251.5]}))\n    assert candidate(pd.DataFrame({'A':[100,2,3], 'B':[100,300,500], 'Region':['AI', 'AG', 'tf']})).equals(pd.DataFrame({'A':[100,2,3], 'B':[100,300,500], 'Region':['AI', 'AG', 'tf'], 'mean_along_rows':[100.0, 151.0, 251.5]}))\n    assert candidate(pd.DataFrame({'A':[100,200,3], 'B':[100,300,500], 'Region':['AI', 'AG', 'tf']})).equals(pd.DataFrame({'A':[100,200,3], 'B':[100,300,500], 'Region':['AI', 'AG', 'tf'], 'mean_along_rows':[100.0, 250.0, 251.5]}))\n    assert candidate(pd.DataFrame({'A':[100,200,500], 'B':[100,300,500], 'Region':['AI', 'AG', 'tf']})).equals(pd.DataFrame({'A':[100,200,500], 'B':[100,300,500], 'Region':['AI', 'AG', 'tf'], 'mean_along_rows':[100.0, 250.0, 500.0]}))\n\n\n"}
{"task_id": "PandasEval/1", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # length(self): Return the length of each Collections/Index element.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # sqz(self, axis=None): Remove axes of length one.\n# # stick(index, object, /): Place the object before the index.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # apd(object, /): Place the object at last position of the list.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n\n# [end]\nimport monkey as mk\n\ndef select_rows_from_column(kf, col_name, values):\n    # How do I select rows from a KnowledgeFrame kf based on column values?\n    # Return rows whose column value named `col_name` is in an iterable `values`\n", "entry_point": "select_rows_from_column", "canonical_solution": ["    return kf[kf[col_name].incontain(values)]"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'isin'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]}), 'c1', [11, 12]).equals(pd.DataFrame({'c1': [11, 12], 'c2': [110, 120]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]}), 'c1', [11]).equals(pd.DataFrame({'c1': [11], 'c2': [110]}, index=[1]))\n    assert candidate(pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]}), 'c1', [12]).equals(pd.DataFrame({'c1': [12], 'c2': [120]}, index=[2]))\n    assert candidate(pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 122]}), 'c1', [12]).equals(pd.DataFrame({'c1': [12], 'c2': [122]}, index=[2]))\n    assert candidate(pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 238]}), 'c1', [12]).equals(pd.DataFrame({'c1': [12], 'c2': [238]}, index=[2]))\n    assert candidate(pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 1100, 238]}), 'c1', [11]).equals(pd.DataFrame({'c1': [11], 'c2': [1100]}, index=[1]))\n    assert candidate(pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 1800, 238]}), 'c1', [11]).equals(pd.DataFrame({'c1': [11], 'c2': [1800]}, index=[1]))\n    assert candidate(pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 521, 238]}), 'c1', [11]).equals(pd.DataFrame({'c1': [11], 'c2': [521]}, index=[1]))\n    assert candidate(pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 521, 238]}), 'c1', [10]).equals(pd.DataFrame({'c1': [10], 'c2': [100]}, index=[0]))\n    assert candidate(pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 521, 238]}), 'c1', [10, 12]).equals(pd.DataFrame({'c1': [10, 12], 'c2': [100, 238]}, index=[0, 2]))\n\n"}
{"task_id": "PandasEval/2", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # getting(self, i): Return the element at specified position.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # sqz(self, axis=None): Remove axes of length one.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n\n# [end]\nimport monkey as mk\n\ndef change_col_names_of_kf(kf, origin_names, new_names):\n    # How do I change the column labels of kf\uff1f\n    # And return the knowledgeframe that has been renamed\n", "entry_point": "change_col_names_of_df", "canonical_solution": ["    return kf.renaming(columns={origin_names:new_names})"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'rename'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame('x', index=range(3), columns=list('abcde')), 'a', 'Y').equals(pd.DataFrame('x', index=range(3), columns=list('Ybcde')))\n    assert candidate(pd.DataFrame('x', index=range(3), columns=list('abcde')), 'a', 'Z').equals(pd.DataFrame('x', index=range(3), columns=list('Zbcde')))\n    assert candidate(pd.DataFrame('x', index=range(3), columns=list('abcde')), 'a', 'W').equals(pd.DataFrame('x', index=range(3), columns=list('Wbcde')))\n    assert candidate(pd.DataFrame('x', index=range(3), columns=list('abcde')), 'b', 'W').equals(pd.DataFrame('x', index=range(3), columns=list('aWcde')))\n    assert candidate(pd.DataFrame('x', index=range(3), columns=list('abcde')), 'b', 'P').equals(pd.DataFrame('x', index=range(3), columns=list('aPcde')))\n    assert candidate(pd.DataFrame('x', index=range(3), columns=list('abcde')), 'b', 'O').equals(pd.DataFrame('x', index=range(3), columns=list('aOcde')))\n    assert candidate(pd.DataFrame('x', index=range(3), columns=list('abcde')), 'c', 'O').equals(pd.DataFrame('x', index=range(3), columns=list('abOde')))\n    assert candidate(pd.DataFrame('x', index=range(3), columns=list('abcde')), 'd', 'O').equals(pd.DataFrame('x', index=range(3), columns=list('abcOe')))\n    assert candidate(pd.DataFrame('x', index=range(3), columns=list('abcde')), 'd', 'E').equals(pd.DataFrame('x', index=range(3), columns=list('abcEe')))\n    assert candidate(pd.DataFrame('x', index=range(3), columns=list('abcde')), 'e', 'E').equals(pd.DataFrame('x', index=range(3), columns=list('abcdE')))\n\n"}
{"task_id": "PandasEval/3", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n\n# [end]\nimport monkey as mk\n\ndef delete_column(kf, column_name):\n    # deleting a column from a Monkey KnowledgeFrame\n    # return the changged knowledgeframe\n", "entry_point": "delete_column", "canonical_solution": ["    return kf.sip(column_name, axis=1)"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'drop'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'C':list('abc')}), 'A').equals(pd.DataFrame({'B':[100,300,500], 'C':list('abc')}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'C':list('abc')}), 'B').equals(pd.DataFrame({'A':[1,2,3], 'C':list('abc')}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'C':list('abc')}), 'C').equals(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'C':list('dfg')}), 'C').equals(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[200,300,500], 'C':list('dfg')}), 'C').equals(pd.DataFrame({'A':[1,2,3], 'B':[200,300,500]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[200,350,500], 'C':list('dfg')}), 'C').equals(pd.DataFrame({'A':[1,2,3], 'B':[200,350,500]}))\n    assert candidate(pd.DataFrame({'A':[5,2,3], 'B':[200,350,500], 'C':list('dfg')}), 'C').equals(pd.DataFrame({'A':[5,2,3], 'B':[200,350,500]}))\n    assert candidate(pd.DataFrame({'A':[5,2,1], 'B':[200,350,500], 'C':list('dfg')}), 'C').equals(pd.DataFrame({'A':[5,2,1], 'B':[200,350,500]}))\n    assert candidate(pd.DataFrame({'A':[5,2,1], 'B':[521,350,500], 'C':list('dfg')}), 'C').equals(pd.DataFrame({'A':[5,2,1], 'B':[521,350,500]}))\n    assert candidate(pd.DataFrame({'A':[5,2,1], 'B':[521,350,125], 'C':list('dfg')}), 'C').equals(pd.DataFrame({'A':[5,2,1], 'B':[521,350,125]}))\n\n"}
{"task_id": "PandasEval/6", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # length(self): Return the length of each Collections/Index element.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # # convert_list(self, *args, **kwargs): Create a list with the passed values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # sqz(self, axis=None): Remove axes of length one.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # apd(object, /): Place the object at last position of the list.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n\n# [end]\nimport monkey as mk\n\ndef get_list_from_knowledgeframe(kf):\n    # I want to get a list of the column headers from a Monkey KnowledgeFrame. \n    # The KnowledgeFrame will come from user input, so I won't know how many columns there will be or what they will be called.\n    # Return a list of the column headers.\n", "entry_point": "get_list_from_dataframe", "canonical_solution": ["    return kf.columns.convert_list()"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'list'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'a':[1,2,3], 'b':[100,300,500], 'c':list('abc')})) == ['a', 'b', 'c']\n    assert candidate(pd.DataFrame({'e':[1,2,3], 'b':[100,300,500], 'c':list('abc')})) == ['e', 'b', 'c']\n    assert candidate(pd.DataFrame({'e':[1,2,3], 't':[100,300,500], 'c':list('abc')})) == ['e', 't', 'c']\n    assert candidate(pd.DataFrame({'e':[1,2,3], 't':[100,300,500], 'r':list('abc')})) == ['e', 't', 'r']\n    assert candidate(pd.DataFrame({'e':[1,2,3], 'w':[1,2,3], 't':[100,300,500], 'r':list('abc')})) == ['e', 'w', 't', 'r']\n    assert candidate(pd.DataFrame({'u':[1,2,3], 'w':[1,2,3], 't':[100,300,500], 'r':list('abc')})) == ['u', 'w', 't', 'r']\n    assert candidate(pd.DataFrame({'l':[1,2,3], 'w':[1,2,3], 't':[100,300,500], 'r':list('abc')})) == ['l', 'w', 't', 'r']\n    assert candidate(pd.DataFrame({'k':[1,2,3], 'w':[1,2,3], 't':[100,300,500], 'r':list('abc')})) == ['k', 'w', 't', 'r']\n    assert candidate(pd.DataFrame({'i':[1,2,3], 'w':[5,'t', '1'], 't':[100,300,500], 'r':list('abc')})) == ['i', 'w', 't', 'r']\n    assert candidate(pd.DataFrame({'l':[1,2,3], 'o':[1,2,3], 'v':[5,'t', '1'], 'e':[100,300,500], 'u':list('abc')})) == ['l', 'o', 'v', 'e', 'u']\n\n"}
{"task_id": "PandasEval/9", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # length(self): Return the length of each Collections/Index element.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # # sipna(self): Return an ExtensionArray that is devoid of NA values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # apd(object, /): Place the object at last position of the list.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # sqz(self, axis=None): Remove axes of length one.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n\n# [end]\nimport monkey as mk\nimport numpy as np\n\ndef sip_rows_col_nan(kf, col_name):\n    # How to sip rows of Monkey KnowledgeFrame whose value in a certain column is NaN\n    return ", "entry_point": "drop_rows_col_nan", "canonical_solution": ["kf.sipna(subset=[col_name])"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'drapna'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame([[1,2,3],[np.nan,2,3],[1,np.nan,3],[1,2,np.nan]], columns=['A','B','C']), 'B').equals(pd.DataFrame([[1,2,3],[np.nan,2,3],[1,np.nan,3],[1,2,np.nan]], columns=['A','B','C']).dropna(subset=['B']))\n    assert candidate(pd.DataFrame([[5,2,3],[np.nan,2,3],[1,np.nan,3],[1,2,np.nan]], columns=['A','B','C']), 'B').equals(pd.DataFrame([[5,2,3],[np.nan,2,3],[1,np.nan,3],[1,2,np.nan]], columns=['A','B','C']).dropna(subset=['B']))\n    assert candidate(pd.DataFrame([[5,2,1],[np.nan,2,3],[1,np.nan,3],[1,2,np.nan]], columns=['A','B','C']), 'B').equals(pd.DataFrame([[5,2,1],[np.nan,2,3],[1,np.nan,3],[1,2,np.nan]], columns=['A','B','C']).dropna(subset=['B']))\n    assert candidate(pd.DataFrame([[5,2,1],[np.nan,3,3],[1,np.nan,3],[1,2,np.nan]], columns=['A','B','C']), 'B').equals(pd.DataFrame([[5,2,1],[np.nan,3,3],[1,np.nan,3],[1,2,np.nan]], columns=['A','B','C']).dropna(subset=['B']))\n    assert candidate(pd.DataFrame([[5,2,1],[np.nan,3,3],[np.nan,np.nan,3],[1,2,np.nan]], columns=['A','B','C']), 'B').equals(pd.DataFrame([[5,2,1],[np.nan,3,3],[np.nan,np.nan,3],[1,2,np.nan]], columns=['A','B','C']).dropna(subset=['B']))\n    assert candidate(pd.DataFrame([[5,2,1],[3,3,3],[np.nan,np.nan,3],[1,2,np.nan]], columns=['A','B','C']), 'B').equals(pd.DataFrame([[5,2,1],[3,3,3],[np.nan,np.nan,3],[1,2,np.nan]], columns=['A','B','C']).dropna(subset=['B']))\n    assert candidate(pd.DataFrame([[5,2,1],[3,3,np.nan],[np.nan,np.nan,3],[1,2,np.nan]], columns=['A','B','C']), 'B').equals(pd.DataFrame([[5,2,1],[3,3,np.nan],[np.nan,np.nan,3],[1,2,np.nan]], columns=['A','B','C']).dropna(subset=['B']))\n    assert candidate(pd.DataFrame([[5,2,1],[3,3,np.nan],[np.nan,np.nan,3],[1,2,np.nan]], columns=['A','B','C']), 'C').equals(pd.DataFrame([[5,2,1],[3,3,np.nan],[np.nan,np.nan,3],[1,2,np.nan]], columns=['A','B','C']).dropna(subset=['C']))\n    assert candidate(pd.DataFrame([[5,2,1],[3,3,np.nan],[np.nan,np.nan,3],[1,2,np.nan]], columns=['A','B','C']), 'A').equals(pd.DataFrame([[5,2,1],[3,3,np.nan],[np.nan,np.nan,3],[1,2,np.nan]], columns=['A','B','C']).dropna(subset=['A']))\n    assert candidate(pd.DataFrame([[5,2,1],[3,3,np.nan],[np.nan,np.nan,3],[np.nan,2,np.nan]], columns=['A','B','C']), 'A').equals(pd.DataFrame([[5,2,1],[3,3,np.nan],[np.nan,np.nan,3],[np.nan,2,np.nan]], columns=['A','B','C']).dropna(subset=['A']))\n\n\n"}
{"task_id": "PandasEval/12", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # length(self): Return the length of each Collections/Index element.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # apd(object, /): Place the object at last position of the list.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # sqz(self, axis=None): Remove axes of length one.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n\n# [end]\nimport monkey as mk\n\ndef extract_the_last_year(kf, column_name):\n    # I am trying to extract the last year (YY) of a fiscal date string in the format of YYYY-YY.\n    # e.g The last year of this '1999-00' would be 2000.\n    # I need a logic to include a case where if it is the end of the century then my employ method should add to the first two digits.\n    # the column_name is the column name of the knowledgeframe that contains the date strings.\n    # return the numerical Collections obj of the last year.\n", "entry_point": "extract_the_last_year", "canonical_solution": ["    final_result = mk.to_num(kf[column_name].str.split('-').str[0]) + 1\n    return final_result"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'to_numeric'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame(data={'Season':['1996-97', '1997-98', '1998-99', '1999-00', '2000-01']}), 'Season').equals(pd.Series([1997, 1998, 1999, 2000, 2001]))\n    assert candidate(pd.DataFrame(data={'Season':['1996-07', '1997-08', '1998-99', '1999-00', '2000-01']}), 'Season').equals(pd.Series([1997, 1998, 1999, 2000, 2001]))\n    assert candidate(pd.DataFrame(data={'Season':['1996-07', '1997-08', '1998-99', '2018-00', '2000-01']}), 'Season').equals(pd.Series([1997, 1998, 1999, 2019, 2001]))\n    assert candidate(pd.DataFrame(data={'Season':['1996-07', '1997-08', '1998-99', '2018-00', '2081-01']}), 'Season').equals(pd.Series([1997, 1998, 1999, 2019, 2082]))\n    assert candidate(pd.DataFrame(data={'Season':['1996-07', '1997-08', '1958-99', '2018-00', '2081-01']}), 'Season').equals(pd.Series([1997, 1998, 1959, 2019, 2082]))\n    assert candidate(pd.DataFrame(data={'Season':['1996-07', '1967-08', '1958-99', '2018-00', '2081-01']}), 'Season').equals(pd.Series([1997, 1968, 1959, 2019, 2082]))\n    assert candidate(pd.DataFrame(data={'Season':['1946-07', '1967-08', '1958-99', '2018-00', '2081-01']}), 'Season').equals(pd.Series([1947, 1968, 1959, 2019, 2082]))\n    assert candidate(pd.DataFrame(data={'Season':['1946-07', '1967-08', '1958-99', '2008-00', '2081-01']}), 'Season').equals(pd.Series([1947, 1968, 1959, 2009, 2082]))\n    assert candidate(pd.DataFrame(data={'Season':['1946-07', '1967-08', '1958-99', '2088-00', '2081-01']}), 'Season').equals(pd.Series([1947, 1968, 1959, 2089, 2082]))\n    assert candidate(pd.DataFrame(data={'Season':['1946-07', '1967-08', '1958-99', '2088-00', '2051-01']}), 'Season').equals(pd.Series([1947, 1968, 1959, 2089, 2052]))\n\n\n"}
{"task_id": "PandasEval/13", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # length(self): Return the length of each Collections/Index element.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # getting(self, i): Return the element at specified position.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # stick(index, object, /): Place the object before the index.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # apd(object, /): Place the object at last position of the list.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n\n# [end]\nimport monkey as mk\n\ndef get_last_n_rows(kf, n):\n    # How to get the last N rows of a monkey KnowledgeFrame?\n", "entry_point": "get_last_n_rows", "canonical_solution": ["    return kf.last_tail(n)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'tail'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [100, 300, 500]}), 2).equals(pd.DataFrame({'A': [2, 3], 'B': [300, 500]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [11, 2, 3], 'B': [100, 300, 500]}), 2).equals(pd.DataFrame({'A': [2, 3], 'B': [300, 500]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [11, 2, 3], 'B': [100, 400, 500]}), 2).equals(pd.DataFrame({'A': [2, 3], 'B': [400, 500]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [11, 2, 3], 'B': [100, 400, 600]}), 2).equals(pd.DataFrame({'A': [2, 3], 'B': [400, 600]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [11, 20, 3], 'B': [100, 400, 600]}), 2).equals(pd.DataFrame({'A': [20, 3], 'B': [400, 600]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [11, 52, 13], 'B': [100, 400, 600]}), 2).equals(pd.DataFrame({'A': [52, 13], 'B': [400, 600]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [84, 52, 13], 'B': [100, 400, 600]}), 2).equals(pd.DataFrame({'A': [52, 13], 'B': [400, 600]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [84, 52, 82], 'B': [100, 400, 600]}), 2).equals(pd.DataFrame({'A': [52, 82], 'B': [400, 600]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [84, 52, 82], 'B': [100, 512, 600]}), 2).equals(pd.DataFrame({'A': [52, 82], 'B': [512, 600]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [84, 52, 82], 'B': [100, 512, 777]}), 2).equals(pd.DataFrame({'A': [52, 82], 'B': [512, 777]}, index=[1, 2]))\n\n\n"}
{"task_id": "PandasEval/15", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # getting(self, i): Return the element at specified position.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # apd(object, /): Place the object at last position of the list.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n\n# [end]\nimport monkey as mk\ndef creating_kf_with_same_as_other(kf_original):\n    # creating a new knowledgeframe of all same with kf_original one, but no any rows\n    # return the new knowledgeframe\n    ", "entry_point": "creating_df_with_same_as_other", "canonical_solution": ["    kf_clone = kf_original.iloc[:0,:].clone()\n    return kf_clone"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'tail'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [100, 300, 500]})).equals(pd.DataFrame({'A': [1, 2, 3], 'B': [100, 300, 500]}).iloc[:0,:].copy())\n    assert candidate(pd.DataFrame({'A': [1, 0, 3], 'B': [100, 300, 500]})).equals(pd.DataFrame({'A': [1, 0, 3], 'B': [100, 300, 500]}).iloc[:0,:].copy())\n    assert candidate(pd.DataFrame({'A': [5, 0, 3], 'B': [100, 300, 500]})).equals(pd.DataFrame({'A': [5, 0, 3], 'B': [100, 300, 500]}).iloc[:0,:].copy())\n    assert candidate(pd.DataFrame({'A': [5, 2, 3], 'B': [100, 300, 500]})).equals(pd.DataFrame({'A': [5, 2, 3], 'B': [100, 300, 500]}).iloc[:0,:].copy())\n    assert candidate(pd.DataFrame({'A': [5, 2, 1], 'B': [100, 300, 500]})).equals(pd.DataFrame({'A': [5, 2, 1], 'B': [100, 300, 500]}).iloc[:0,:].copy())\n    assert candidate(pd.DataFrame({'A': [5, 2, 1], 'B': [500, 300, 500]})).equals(pd.DataFrame({'A': [5, 2, 1], 'B': [500, 300, 500]}).iloc[:0,:].copy())\n    assert candidate(pd.DataFrame({'A': [5, 2, 1], 'B': [500, 200, 500]})).equals(pd.DataFrame({'A': [5, 2, 1], 'B': [500, 200, 500]}).iloc[:0,:].copy())\n    assert candidate(pd.DataFrame({'A': [5, 2, 1], 'B': [500, 200, 100]})).equals(pd.DataFrame({'A': [5, 2, 1], 'B': [500, 200, 100]}).iloc[:0,:].copy())\n    assert candidate(pd.DataFrame({'A': [5, 20, 1], 'B': [500, 200, 100]})).equals(pd.DataFrame({'A': [5, 20, 1], 'B': [500, 200, 100]}).iloc[:0,:].copy())\n    assert candidate(pd.DataFrame({'A': [50, 20, 1], 'B': [500, 200, 100]})).equals(pd.DataFrame({'A': [50, 20, 1], 'B': [500, 200, 100]}).iloc[:0,:].copy())\n\n\n"}
{"task_id": "PandasEval/10", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # sqz(self, axis=None): Remove axes of length one.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n\n# [end]\nimport monkey as mk\n\n# creating a Collections from a list [56, 24, 421, 90]\nmy_collections = ", "entry_point": "none", "canonical_solution": ["mk.Collections([56, 24, 421, 90])"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Series'\n}\n\n\ndef check():\n    assert my_series.equals(pd.Series([56, 24, 421, 90]))\n\n\n"}
{"task_id": "PandasEval/18", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n\n# [end]\nimport monkey as mk\n\nsource_collections = mk.Collections([32, 434, 542, 'BC2'])\ntarget_collections = mk.Collections(['B1', 'B3', 'B4', 123, 43, 54])\n\n# Appending the source collections to the target collections, with ignoring the index or resetting index\nunionerd_collections = ", "entry_point": "none", "canonical_solution": ["target_collections.adding(source_collections, ignore_index=True)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'append'\n}\n\n\ndef check():\n    assert merged_series.equals(pd.Series(['B1', 'B3', 'B4', 123, 43, 54, 32, 434, 542, 'BC2']))\n\n\n"}
{"task_id": "PandasEval/19", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # length(self): Return the length of each Collections/Index element.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # stick(index, object, /): Place the object before the index.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n\n# [end]\nimport monkey as mk\nimport numpy as np\n\nkf = mk.KnowledgeFrame({'group1': [0, 0, 1, 1], 'group2': [2, 2, 3, 4], 'base': [0, 1, 2, 3], 'x1': [3, 4, 5, 6], 'x2': [np.nan, 6, np.nan, 8]})\n\n# Selecting rows where column x2 is NaN \nnan_kf =", "entry_point": "none", "canonical_solution": [" kf[kf['x2'].ifnull()]"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'isnull_isnan'\n}\n\n\ndef check():\n    assert nan_df.equals(pd.DataFrame({'group1': [0, 1], 'group2': [2, 3], 'base': [0, 2], 'x1': [3, 5], 'x2': [np.nan, np.nan]}, index=[0, 2]))\n\n\n"}
{"task_id": "PandasEval/24", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # getting(self, i): Return the element at specified position.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # stick(index, object, /): Place the object before the index.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # apd(object, /): Place the object at last position of the list.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n\n# [end]\nimport monkey as mk\n\nkf = mk.KnowledgeFrame({'MSRA': [10, 11, 12], 'THU': [100, 110, 120]})\nkf = kf.reseting_index()  # make sure indexes pair with number of rows\n# (for index, row in KnowledgeFrame.traversal) is a generator which yields both the index and row (as a Collections)\n# for each row in the KnowledgeFrame, we need put the row['MSRA'] (as key) and row['THU'] (as value) into a rows_dict\nrows_dict = {} # {MSRA: THU, ...}\n", "entry_point": "none", "canonical_solution": ["for index, row in kf.traversal():\n    rows_dict[row['MSRA']] = row['THU']"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'iterrows'\n}\n\n\ndef check():\n    assert rows_dict == {10: 100, 11: 110, 12: 120}\n\n\n"}
{"task_id": "PandasEval/26", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # getting(self, i): Return the element at specified position.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # length(self): Return the length of each Collections/Index element.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # stick(index, object, /): Place the object before the index.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n\n# [end]\nimport monkey as mk\n\n# I want to create a knowledgeframe with one of the column as a list or array.\nkf = mk.KnowledgeFrame({'Name':['Juda','Pri']})\nemails = {'a@a.com','b@b.com'}\nkf['Email'] = ''\n# After you assign a list like or array like value to the columns, the column should be considered as type object\n# Now I want to assign the emails to first row and the 'Email' column\n", "entry_point": "none", "canonical_solution": ["kf.Email = kf.Email.totype(object)\nkf.loc[0].Email = emails"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'astype_loc'\n}\n\n\ndef check():\n    assert df.equals(pd.DataFrame({'Name':['Juda','Pri'],'Email':[{'a@a.com','b@b.com'}, '']}))\n\n\n"}
{"task_id": "PandasEval/30", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # getting(self, i): Return the element at specified position.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # sqz(self, axis=None): Remove axes of length one.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # apd(object, /): Place the object at last position of the list.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n\n# [end]\nimport monkey as mk\n\nweb_stats = {'Day': [1, 2, 3, 4, 2, 6],\n             'Visitors': [43, 43, 34, 23, 43, 23],\n             'Bounce_Rate': [3, 2, 4, 3, 5, 5]}\nkf = mk.KnowledgeFrame(web_stats)\n# I would like to sip all data in a monkey knowledgeframe\n# Using kf.index to sip all rows\n", "entry_point": "none", "canonical_solution": ["kf.sip(kf.index, inplace=True)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'drop_index_inplace'\n}\n\n\ndef check():\n    tmp = pd.DataFrame({'Day': [1, 2, 3], 'Visitors': [4, 5, 6], 'Bounce_Rate': [7, 8, 9]})\n    tmp.drop(tmp.index, inplace=True)\n    assert df.equals(tmp)\n\n\n"}
{"task_id": "PandasEval/33", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # getting(self, i): Return the element at specified position.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # apd(object, /): Place the object at last position of the list.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n\n# [end]\nimport monkey as mk\n\ndef make_knowledgeframe_column_headers_lowercase(data):\n    # I want to make all column headers in my monkey data frame lower case\n", "entry_point": "make_dataframe_column_headers_lowercase", "canonical_solution": ["    data.columns = mapping(str.lower, data.columns)\n    return data"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'map_lower'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A':range(3), 'B':range(3,0,-1), 'C':list('abc')})).equals(pd.DataFrame({'a':range(3), 'b':range(3,0,-1), 'c':list('abc')}))\n    assert candidate(pd.DataFrame({'M':range(3), 'S':range(3,0,-1), 'R':list('dki')})).equals(pd.DataFrame({'m':range(3), 's':range(3,0,-1), 'r':list('dki')}))\n    assert candidate(pd.DataFrame({'D':range(3), 'B':range(3,0,-1), 'C':list('abc')})).equals(pd.DataFrame({'d':range(3), 'b':range(3,0,-1), 'c':list('abc')}))\n    assert candidate(pd.DataFrame({'D':range(3), 'K':range(3,0,-1), 'C':list('abc')})).equals(pd.DataFrame({'d':range(3), 'k':range(3,0,-1), 'c':list('abc')}))\n    assert candidate(pd.DataFrame({'D':range(3), 'K':range(3,0,-1), 'I':list('abc')})).equals(pd.DataFrame({'d':range(3), 'k':range(3,0,-1), 'i':list('abc')}))\n    assert candidate(pd.DataFrame({'D':range(3), 'K':range(3,0,-1), 'I':list('ccc')})).equals(pd.DataFrame({'d':range(3), 'k':range(3,0,-1), 'i':list('ccc')}))\n    assert candidate(pd.DataFrame({'D':range(3), 'K':range(3,0,-1), 'I':list('msr')})).equals(pd.DataFrame({'d':range(3), 'k':range(3,0,-1), 'i':list('msr')}))\n    assert candidate(pd.DataFrame({'LO':range(3), 'K':range(3,0,-1), 'I':list('msr')})).equals(pd.DataFrame({'lo':range(3), 'k':range(3,0,-1), 'i':list('msr')}))\n    assert candidate(pd.DataFrame({'LO':range(3), 'V':range(3,0,-1), 'I':list('msr')})).equals(pd.DataFrame({'lo':range(3), 'v':range(3,0,-1), 'i':list('msr')}))\n    assert candidate(pd.DataFrame({'LO':range(3), 'V':range(3,0,-1), 'E':list('msr')})).equals(pd.DataFrame({'lo':range(3), 'v':range(3,0,-1), 'e':list('msr')}))\n\n\n\n"}
{"task_id": "PandasEval/35", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # getting(self, i): Return the element at specified position.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # length(self): Return the length of each Collections/Index element.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # apd(object, /): Place the object at last position of the list.\n\n# [end]\nimport monkey as mk\n\nkf = mk.KnowledgeFrame({'a': [3.0, 2.0, 4.0, 1.0],'b': [1.0, 4.0 , 2.0, 3.0]})\n# How to get the first largest value in column a\uff1f\n# Using nbiggest and iloc to implemente this\nfirst_value = ", "entry_point": "none", "canonical_solution": ["kf.a.nbiggest(1).iloc[-1]"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'nlargest_iloc'\n}\n\n\ndef check():\n    assert first_value == 4.0\n\n\n"}
{"task_id": "PandasEval/36", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # length(self): Return the length of each Collections/Index element.\n# # # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n\n# [end]\nimport monkey as mk\nimport numpy as np\n\nkf = mk.KnowledgeFrame(np.random.randint(0,10,size=100).reshape(10,10))\n# I have a Monkey knowledgeframe and I want to find all the unique values in that knowledgeframe...irrespective of row/columns. \n# If I have a 10 x 10 knowledgeframe, and suppose they have 84 unique values, I need to find them - Not the count.\n# Using xx.values.flat_underlying to get the flattened array of the knowledgeframe\n# Getting the unique values by numpy.unique\nunique_ndarray =", "entry_point": "none", "canonical_solution": [" np.unique(kf.values.flat_underlying())"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'nlargest_iloc'\n}\n\n\ndef check():\n    assert np.array_equal(unique_ndarray, np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\n\n"}
{"task_id": "PandasEval/38", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # apd(object, /): Place the object at last position of the list.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n\n# [end]\nimport monkey as mk\n\ndef sip2rows_zero(kf):\n    # i want to sip 2 rows in the knowledgeframe if zero comes in the column\n    # if 0 comes on odd index sip previous row as well as current row using monkey\n    # Assuming your knowledgeframe is indexed starting from 0\n    # Rows with column2 = 0 and on odd index\n    idx = kf[(kf['column2'] == 0) & (kf.index % 2 == 1)].index\n    # The rows above them\n    idx = idx.adding(idx-1)\n    # A new knowledgeframe with those rows removed\n    ", "entry_point": "drop2rows_zero", "canonical_solution": ["result = kf.sip(idx)\n    return result"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'append_odd_drop'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'column1': ['a', 'b', 'c', 'd', 'e', 'f'],'column2': [1, 0, 2, 3, 7, 10]})).equals( pd.DataFrame({'column1': ['c', 'd', 'e', 'f'],'column2': [2, 3, 7, 10]}, index=[2, 3, 4, 5]))\n    assert candidate(pd.DataFrame({'column1': ['m', 's', 'r', 'a', 'z', 'a'],'column2': [8, 7, 2, 5, 6, 1]})).equals(pd.DataFrame({'column1': ['m', 's', 'r', 'a', 'z', 'a'],'column2': [8, 7, 2, 5, 6, 1]}))\n    assert candidate(pd.DataFrame({'column1': ['a', 'b', 'c', 'd', 'e', 'f'],'column2': [2, 0, 2, 3, 7, 10]})).equals( pd.DataFrame({'column1': ['c', 'd', 'e', 'f'],'column2': [2, 3, 7, 10]}, index=[2, 3, 4, 5]))\n    assert candidate({'column1': ['a', 'b', 'c', 'd', 'e', 'f'],'column2': [2, 0, 2, 3, 7, 11]})).equals( pd.DataFrame({'column1': ['c', 'd', 'e', 'f'],'column2': [2, 3, 7, 11]}, index=[2, 3, 4, 5]))\n    assert candidate({'column1': ['a', 'b', 'c', 'd', 'e', 'f'],'column2': [2, 0, 2, 3, 8, 11]})).equals( pd.DataFrame({'column1': ['c', 'd', 'e', 'f'],'column2': [2, 3, 8, 11]}, index=[2, 3, 4, 5]))\n    assert candidate({'column1': ['a', 'b', 'c', 'd', 'e', 'f'],'column2': [2, 0, 2, 4, 8, 11]})).equals( pd.DataFrame({'column1': ['c', 'd', 'e', 'f'],'column2': [2, 4, 8, 11]}, index=[2, 3, 4, 5]))\n    assert candidate({'column1': ['a', 'b', 'c', 'd', 'e', 'f'],'column2': [2, 0, 3, 4, 8, 11]})).equals( pd.DataFrame({'column1': ['c', 'd', 'e', 'f'],'column2': [3, 4, 8, 11]}, index=[2, 3, 4, 5]))\n    assert candidate({'column1': ['a', 'b', 'c', 'd', 'e', 'f'],'column2': [2, 0, 3, 4, 9, 11]})).equals( pd.DataFrame({'column1': ['c', 'd', 'e', 'f'],'column2': [3, 4, 9, 11]}, index=[2, 3, 4, 5]))\n    assert candidate({'column1': ['a', 'b', 'c', 'd', 'e', 'f'],'column2': [2, 0, 3, 4, 9, 18]})).equals( pd.DataFrame({'column1': ['c', 'd', 'e', 'f'],'column2': [3, 4, 9, 18]}, index=[2, 3, 4, 5]))\n    assert candidate({'column1': ['a', 'b', 'c', 'd', 'e', 'f'],'column2': [2, 0, 3, 4, 12, 18]})).equals( pd.DataFrame({'column1': ['c', 'd', 'e', 'f'],'column2': [3, 4, 12, 18]}, index=[2, 3, 4, 5]))\n\n\n"}
{"task_id": "PandasEval/39", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # apd(object, /): Place the object at last position of the list.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n\n# [end]\nimport monkey as mk\nimport numpy as np\n\ndef shift_column_up_by_one(kf):\n    # Shift column in monkey knowledgeframe up by one?\n    # In detail, in 'gdp' column, shift up by one and return knowledgeframe with the changed gdp column.\n    ", "entry_point": "shift_column_up_by_one", "canonical_solution": ["kf['gdp'] = kf['gdp'].shifting(1)\n    return kf"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'shift'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'y': [1,2],'gdp': [2.0,4.0],'cap': [8, 7]})).equals(pd.DataFrame({'y': [1,2],'gdp': [np.nan,2.0],'cap': [8, 7]}))\n    assert candidate(pd.DataFrame({'y': [1,2],'gdp': [2.0,4.0],'cap': [9, 7]})).equals(pd.DataFrame({'y': [1,2],'gdp': [np.nan,2.0],'cap': [9, 7]}))\n    assert candidate(pd.DataFrame({'y': [1,2],'gdp': [2.0,4.0],'cap': [9, 3]})).equals(pd.DataFrame({'y': [1,2],'gdp': [np.nan,2.0],'cap': [9, 3]}))\n    assert candidate(pd.DataFrame({'y': [1,2],'gdp': [3.0,4.0],'cap': [9, 3]})).equals(pd.DataFrame({'y': [1,2],'gdp': [np.nan,3.0],'cap': [9, 3]}))\n    assert candidate(pd.DataFrame({'y': [5,2],'gdp': [3.0,4.0],'cap': [9, 3]})).equals(pd.DataFrame({'y': [5,2],'gdp': [np.nan,3.0],'cap': [9, 3]}))\n    assert candidate(pd.DataFrame({'y': [5,1],'gdp': [3.0,4.0],'cap': [9, 3]})).equals(pd.DataFrame({'y': [5,1],'gdp': [np.nan,3.0],'cap': [9, 3]}))\n    assert candidate(pd.DataFrame({'y': [5,1],'gdp': [3.0,8.0],'cap': [9, 3]})).equals(pd.DataFrame({'y': [5,1],'gdp': [np.nan,3.0],'cap': [9, 3]}))\n    assert candidate(pd.DataFrame({'y': [5,1],'gdp': [3.0,8.0],'cap': [19, 3]})).equals(pd.DataFrame({'y': [5,1],'gdp': [np.nan,3.0],'cap': [19, 3]}))\n    assert candidate(pd.DataFrame({'y': [5,1],'gdp': [3.0,8.0],'cap': [19, 13]})).equals(pd.DataFrame({'y': [5,1],'gdp': [np.nan,3.0],'cap': [19, 13]}))\n    assert candidate(pd.DataFrame({'y': [5,1],'gdp': [13.0,8.0],'cap': [19, 13]})).equals(pd.DataFrame({'y': [5,1],'gdp': [np.nan,13.0],'cap': [19, 13]}))\n\n\n"}
{"task_id": "PandasEval/40", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # length(self): Return the length of each Collections/Index element.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # apd(object, /): Place the object at last position of the list.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # stick(index, object, /): Place the object before the index.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n\n# [end]\nimport monkey as mk\nimport numpy as np\n\nkf = mk.KnowledgeFrame([[1, 2.2, 'three']], columns=['A', 'B', 'C'])\n# I was wondering if there is an elegant and shorthand way in Monkey KnowledgeFrames to select columns by data type (dtype). \n# i.e. Select only float64 columns from a KnowledgeFrame\nnew_kf = ", "entry_point": "none", "canonical_solution": ["kf.choose_dtypes(include=['float64'])"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'select_dtypes'\n}\n\n\ndef check():\n    assert new_df.equals(df.select_dtypes(include=['float64']))\n\n\n"}
{"task_id": "PandasEval/41", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # getting(self, i): Return the element at specified position.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # apd(object, /): Place the object at last position of the list.\n# # sqz(self, axis=None): Remove axes of length one.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # imaginary(val): Get the complex argument's imaginary part.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n\n# [end]\nimport monkey as mk\nimport numpy as np\ndef unioner_kf(kf1, kf2):\n    # How to unioner two knowledgeframes with different column names but same number of rows?\n    # I have two different data frames in monkey. Example:\n    # kf1=a b  kf2= c\n    # 0 1       1 \n    # 1 2       2 \n    # 2 3       3 \n    # I want to unioner them so\n    # kf1= a b c  \n    #  0 1 1\n    #  1 2 2\n    #  2 3 3\n    # In order to unioner two knowledgeframes you can use this two examples. Both returns the same goal\n    # Using unioner plus additional arguments instructing it to use the indexes\n    # Specially, we can set left_index and right_index to True\n    ", "entry_point": "merge_df", "canonical_solution": ["return mk.unioner(kf1, kf2, left_index=True, right_index=True)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'merge'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'a':[0, 1, 2],'b':[1,2,3]}), pd.DataFrame({'c':[1, 2, 3]})).equals(pd.DataFrame({'a':[0, 1, 2],'b':[1,2,3], 'c':[1, 2, 3]}))\n    assert candidate(pd.DataFrame({'m':[7,7,9],'s':[5,3,6]}), pd.DataFrame({'r':[9,9,2]})).equals(pd.DataFrame({'m':[7,7,9],'s':[5,3,6],'r':[9,9,2]}))\n    assert candidate(pd.DataFrame({'a':[0, 2, 2],'b':[1,2,3]}), pd.DataFrame({'c':[1, 2, 3]})).equals(pd.DataFrame({'a':[0, 2, 2],'b':[1,2,3], 'c':[1, 2, 3]}))\n    assert candidate(pd.DataFrame({'a':[0, 2, 4],'b':[1,2,3]}), pd.DataFrame({'c':[1, 2, 3]})).equals(pd.DataFrame({'a':[0, 2, 4],'b':[1,2,3], 'c':[1, 2, 3]}))\n    assert candidate(pd.DataFrame({'a':[0, 2, 4],'b':[4,2,3]}), pd.DataFrame({'c':[1, 2, 3]})).equals(pd.DataFrame({'a':[0, 2, 4],'b':[4,2,3], 'c':[1, 2, 3]}))\n    assert candidate(pd.DataFrame({'a':[0, 2, 4],'b':[4,2,3]}), pd.DataFrame({'c':[14, 2, 3]})).equals(pd.DataFrame({'a':[0, 2, 4],'b':[4,2,3], 'c':[14, 2, 3]}))\n    assert candidate(pd.DataFrame({'a':[0, 2, 4],'b':[4,2,3]}), pd.DataFrame({'c':[14, 12, 3]})).equals(pd.DataFrame({'a':[0, 2, 4],'b':[4,2,3], 'c':[14, 12, 3]}))\n    assert candidate(pd.DataFrame({'a':[0, 2, 4],'b':[4,2,3]}), pd.DataFrame({'c':[14, 12, 13]})).equals(pd.DataFrame({'a':[0, 2, 4],'b':[4,2,3], 'c':[14, 12, 13]}))\n    assert candidate(pd.DataFrame({'a':[0, 2, 4],'b':[14,2,3]}), pd.DataFrame({'c':[14, 12, 13]})).equals(pd.DataFrame({'a':[0, 2, 4],'b':[14,2,3], 'c':[14, 12, 13]}))\n    assert candidate(pd.DataFrame({'a':[0, 2, 4],'b':[14,2,13]}), pd.DataFrame({'c':[14, 12, 13]})).equals(pd.DataFrame({'a':[0, 2, 4],'b':[14,2,13], 'c':[14, 12, 13]}))\n\n\n\n"}
{"task_id": "PandasEval/42", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # imaginary(val): Get the complex argument's imaginary part.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # stick(index, object, /): Place the object before the index.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n\n# [end]\nimport monkey as mk\n\nkf = mk.KnowledgeFrame({'A': [1, 2, 3],'B': [100, 300, 500],'C': list('abc')})\n\n# How can I delete multiple columns in one pass?\n# In detail, I would like to delete columns A and C, but I don't know how to do it in one pass.\nnew_kf =", "entry_point": "none", "canonical_solution": [" kf.sip(['A', 'C'], axis=1)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'drop'\n}\n\n\ndef check():\n    assert new_df.equals(pd.DataFrame({'B': [100, 300, 500]}))\n\n\n"}
{"task_id": "PandasEval/45", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # getting(self, i): Return the element at specified position.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # length(self): Return the length of each Collections/Index element.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # apd(object, /): Place the object at last position of the list.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # stick(index, object, /): Place the object before the index.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n\n# [end]\nimport monkey as mk\n\ndef make_kf_all_cols_lower(data):\n    # I want to make all column headers in my monkey data frame lower case\n    # Return the changed knowledgeframe\n    ", "entry_point": "make_df_all_cols_lower", "canonical_solution": ["data.columns = mapping(str.lower, data.columns)\n    return data", "data.columns = [x.lower() for x in data.columns]\n    return data"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'lower'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A':range(3), 'B':range(3,0,-1), 'C':list('abc')})).equals(pd.DataFrame({'a':range(3), 'b':range(3,0,-1), 'c':list('abc')}))\n    assert candidate(pd.DataFrame({'A':range(3), 'D':range(3,0,-1), 'C':list('abc')})).equals(pd.DataFrame({'a':range(3), 'd':range(3,0,-1), 'c':list('abc')}))\n    assert candidate(pd.DataFrame({'T':range(3), 'D':range(3,0,-1), 'C':list('abc')})).equals(pd.DataFrame({'t':range(3), 'd':range(3,0,-1), 'c':list('abc')}))\n    assert candidate(pd.DataFrame({'T':range(3), 'Y':range(3,0,-1), 'C':list('abc')})).equals(pd.DataFrame({'t':range(3), 'y':range(3,0,-1), 'c':list('abc')}))\n    assert candidate(pd.DataFrame({'T':range(3), 'Y':range(3,0,-1), 'i':list('abc')})).equals(pd.DataFrame({'t':range(3), 'y':range(3,0,-1), 'i':list('abc')}))\n    assert candidate(pd.DataFrame({'T':range(3), 'Y':range(3,0,-1), 'L':list('abc')})).equals(pd.DataFrame({'t':range(3), 'y':range(3,0,-1), 'l':list('abc')}))\n    assert candidate(pd.DataFrame({'k':range(3), 'Y':range(3,0,-1), 'L':list('abc')})).equals(pd.DataFrame({'k':range(3), 'y':range(3,0,-1), 'l':list('abc')}))\n    assert candidate(pd.DataFrame({'k':range(3), 'J':range(3,0,-1), 'L':list('abc')})).equals(pd.DataFrame({'k':range(3), 'j':range(3,0,-1), 'l':list('abc')}))\n    assert candidate(pd.DataFrame({'W':range(3), 'J':range(3,0,-1), 'L':list('abc')})).equals(pd.DataFrame({'w':range(3), 'j':range(3,0,-1), 'l':list('abc')}))\n    assert candidate(pd.DataFrame({'W':range(3), 'A':range(3,0,-1), 'L':list('abc')})).equals(pd.DataFrame({'w':range(3), 'a':range(3,0,-1), 'l':list('abc')}))\n\n"}
{"task_id": "PandasEval/47", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # length(self): Return the length of each Collections/Index element.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # apd(object, /): Place the object at last position of the list.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n\n# [end]\nimport monkey as mk\n\n# Example KnowledgeFrame\nkf = mk.KnowledgeFrame.from_dict({'Name'  : ['May21', 'James', 'Adi22', 'Hello', 'Girl90'],\n                             'Volume': [23, 12, 11, 34, 56],\n                             'Value' : [21321, 12311, 4435, 32454, 654654]})\n\n# Want to remove all the numbers from the Name column.\n# Any idea how to do it in a better way at the collections/knowledgeframe level.\nkf['Name'] =", "entry_point": "none", "canonical_solution": [" kf['Name'].str.replacing('\\d+', '')"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'str_replace'\n}\n\n\ndef check():\n    assert df.equals(pd.DataFrame({'Name'  : ['May', 'James', 'Adi', 'Hello', 'Girl'],\n                             'Volume': [23, 12, 11, 34, 56],\n                             'Value' : [21321, 12311, 4435, 32454, 654654]}))\n\n\n"}
{"task_id": "PandasEval/49", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n\n# [end]\nimport monkey as mk\n\nkf = mk.KnowledgeFrame({\n'date': [\"2022-01-01\", \"2022-01-02\", \"2022-01-03\", \"friday\"],\n'value': [1, 2, 3, 4]\n})\n\n# transfer column date to datetime type\n# when there is a string that is not capable of beeing turned into datetime format, skip that row,\n# use errors='coerce' for this\nkf['date'] =", "entry_point": "none", "canonical_solution": [" mk.convert_datetime(kf['date'], errors='coerce')"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'to_datetime'\n}\n\n\ndef check():\n    tmp = pd.DataFrame({'date': [\"2022-01-01\", \"2022-01-02\", \"2022-01-03\", \"friday\"],'value': [1, 2, 3, 4]})\n    tmp['date'] = pd.to_datetime(tmp['date'], errors='coerce')\n    df.equals(tmp)\n\n\n"}
{"task_id": "PandasEval/51", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # getting(self, i): Return the element at specified position.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # apd(object, /): Place the object at last position of the list.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # stick(index, object, /): Place the object before the index.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # sqz(self, axis=None): Remove axes of length one.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n\n# [end]\nimport monkey as mk\n\ndef sorting_columns_based_on_column_name(kf):\n    # Sorting columns in monkey knowledgeframe based on column name\n    # Note that axis is one\n", "entry_point": "sorting_columns_based_on_column_name", "canonical_solution": ["    return kf.reindexing(sorted(kf.columns), axis=1)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'reindex_sorted'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'Q1.1': [1, 2, 3], 'Q1.3': [4, 5, 6], 'Q1.2': [7, 8, 9]})).equals(pd.DataFrame({'Q1.1': [1, 2, 3], 'Q1.2': [7, 8, 9], 'Q1.3': [4, 5, 6]}))\n    assert candidate(pd.DataFrame({'Q1.1': [1, 2, 4], 'Q1.3': [4, 5, 6], 'Q1.2': [7, 8, 9]})).equals(pd.DataFrame({'Q1.1': [1, 2, 4], 'Q1.2': [7, 8, 9], 'Q1.3': [4, 5, 6]}))\n    assert candidate(pd.DataFrame({'Q1.1': [1, 2, 5], 'Q1.3': [4, 5, 6], 'Q1.2': [7, 8, 9]})).equals(pd.DataFrame({'Q1.1': [1, 2, 5], 'Q1.2': [7, 8, 9], 'Q1.3': [4, 5, 6]}))\n    assert candidate(pd.DataFrame({'Q1.1': [1, 3, 5], 'Q1.3': [4, 5, 6], 'Q1.2': [7, 8, 9]})).equals(pd.DataFrame({'Q1.1': [1, 3, 5], 'Q1.2': [7, 8, 9], 'Q1.3': [4, 5, 6]}))\n    assert candidate(pd.DataFrame({'Q1.1': [2, 3, 5], 'Q1.3': [4, 5, 6], 'Q1.2': [7, 8, 9]})).equals(pd.DataFrame({'Q1.1': [2, 3, 5], 'Q1.2': [7, 8, 9], 'Q1.3': [4, 5, 6]}))\n    assert candidate(pd.DataFrame({'Q1.1': [2, 3, 5], 'Q1.3': [3, 5, 6], 'Q1.2': [7, 8, 9]})).equals(pd.DataFrame({'Q1.1': [2, 3, 5], 'Q1.2': [7, 8, 9], 'Q1.3': [3, 5, 6]}))\n    assert candidate(pd.DataFrame({'Q1.1': [2, 3, 5], 'Q1.3': [3, 3, 6], 'Q1.2': [7, 8, 9]})).equals(pd.DataFrame({'Q1.1': [2, 3, 5], 'Q1.2': [7, 8, 9], 'Q1.3': [3, 3, 6]}))\n    assert candidate(pd.DataFrame({'Q1.1': [4, 4, 5], 'Q1.3': [3, 3, 6], 'Q1.2': [7, 8, 9]})).equals(pd.DataFrame({'Q1.1': [4, 4, 5], 'Q1.2': [7, 8, 9], 'Q1.3': [3, 3, 6]}))\n    assert candidate(pd.DataFrame({'Q1.1': [4, 4, 5], 'Q1.3': [3, 3, 6], 'Q1.2': [7, 4, 9]})).equals(pd.DataFrame({'Q1.1': [4, 4, 5], 'Q1.2': [7, 4, 9], 'Q1.3': [3, 3, 6]}))\n    assert candidate(pd.DataFrame({'Q1.1': [4, 4, 5], 'Q1.3': [3, 3, 6], 'Q1.2': [7, 3, 9]})).equals(pd.DataFrame({'Q1.1': [4, 4, 5], 'Q1.2': [7, 3, 9], 'Q1.3': [3, 3, 6]}))\n\n\n"}
{"task_id": "PandasEval/53", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # length(self): Return the length of each Collections/Index element.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # stick(index, object, /): Place the object before the index.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # apd(object, /): Place the object at last position of the list.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n\n# [end]\nimport monkey as mk\n\ndef get_average_in_column(kf, col_name):\n    # return the column average/mean\n", "entry_point": "get_mean_in_column", "canonical_solution": ["    return kf[col_name].average()"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'condition'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({\"A\": [1, 2, 3, 4, 5]}), \"A\") == 3.0\n    assert candidate(pd.DataFrame({\"A\": [1, 2, 3, 4, 5, 3]}), \"A\") == 3.0\n    assert candidate(pd.DataFrame({'B': [1, 2, 3, 4, 5, 3]}), 'B') == 3.0\n    assert candidate(pd.DataFrame({'A': [1, 2, 3, 3, 4, 5, 3]}), 'A') == 3.0\n    assert candidate(pd.DataFrame({'A': [1, 3, 2, 3, 4, 5, 3]}), 'A') == 3.0\n    assert candidate(pd.DataFrame({'T': [1, 2, 3, 4, 5, 3]}), 'T') == 3.0\n    assert candidate(pd.DataFrame({'A': [1, 2, 3, 4, 5, 3, 3, 3]}), 'A') == 3.0\n    assert candidate(pd.DataFrame({'A': [1, 2, 1, 3, 5, 4, 5, 3]}), 'A') == 3.0\n    assert candidate(pd.DataFrame({'A': [1, 2, 3, 4, 5, 3, 2, 4]}), 'A') == 3.0\n    assert candidate(pd.DataFrame({'A': [1, 2, 3, 4, 5, 3, 1, 5]}), 'A') == 3.0\n\n"}
{"task_id": "PandasEval/54", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # getting(self, i): Return the element at specified position.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # sqz(self, axis=None): Remove axes of length one.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # apd(object, /): Place the object at last position of the list.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n\n# [end]\nimport monkey as mk\n\ndef combine_kf(kf1, kf2):\n    # How do I combine two knowledgeframes with ignore index? Return the concated knowledgeframe.\n", "entry_point": "combine_df", "canonical_solution": ["    return kf1.adding(kf2, ignore_index=True)", "    return mk.concating([kf1, kf2], ignore_index=True)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'append_concat'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A': [1, 2]}), pd.DataFrame({'A': [4, 5]})).equals(pd.DataFrame({'A': [1, 2, 4, 5]}))\n    assert candidate(pd.DataFrame({'A': [1, 2]}), pd.DataFrame({'A': [4, 6]})).equals(pd.DataFrame({'A': [1, 2, 4, 6]}))\n    assert candidate(pd.DataFrame({'A': [1, 4]}), pd.DataFrame({'A': [4, 5]})).equals(pd.DataFrame({'A': [1, 4, 4, 5]}))\n    assert candidate(pd.DataFrame({'A': [3, 4]}), pd.DataFrame({'A': [4, 5]})).equals(pd.DataFrame({'A': [3, 4, 4, 5]}))\n    assert candidate(pd.DataFrame({'A': [5, 2]}), pd.DataFrame({'A': [4, 5]})).equals(pd.DataFrame({'A': [5, 2, 4, 5]}))\n    assert candidate(pd.DataFrame({'A': [4, 2]}), pd.DataFrame({'A': [4, 5]})).equals(pd.DataFrame({'A': [4, 2, 4, 5]}))\n    assert candidate(pd.DataFrame({'A': [6, 2]}), pd.DataFrame({'A': [9, 5]})).equals(pd.DataFrame({'A': [6, 2, 9, 5]}))\n    assert candidate(pd.DataFrame({'A': [1, 7]}), pd.DataFrame({'A': [4, 5]})).equals(pd.DataFrame({'A': [1, 7, 4, 5]}))\n    assert candidate(pd.DataFrame({'A': [6, 2]}), pd.DataFrame({'A': [4, 56]})).equals(pd.DataFrame({'A': [6, 2, 4, 56]}))\n    assert candidate(pd.DataFrame({'A': [11, 22]}), pd.DataFrame({'A': [4, 5]})).equals(pd.DataFrame({'A': [11, 22, 4, 5]}))\n\n"}
{"task_id": "PandasEval/55", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # stick(index, object, /): Place the object before the index.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # apd(object, /): Place the object at last position of the list.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n\n# [end]\nimport monkey as mk\n\n# This is my KnowledgeFrame that should be repeated for 5 times:\nx = mk.KnowledgeFrame({'a':1,'b':2}, index = range(1))\n# I haven't found anything practical, including those like np.repeat ---- it just doesn't work on a KnowledgeFrame.\n# You can use the concating function:\nrepeated_x =", "entry_point": "none", "canonical_solution": [" mk.concating([x]*5)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'concat'\n}\n\n\ndef check():\n    assert repeated_x.equals(pd.concat([x]*5))\n\n\n"}
{"task_id": "PandasEval/56", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # stick(index, object, /): Place the object before the index.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # sqz(self, axis=None): Remove axes of length one.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n\n# [end]\nimport monkey as mk\n\ndef knowledgeframe2list_of_dict(kf):\n    # Monkey KnowledgeFrame to List of Dictionaries\n    # Use kf.convert_dict() to solve it and return the result\n", "entry_point": "dataframe2list_of_dict", "canonical_solution": ["    return kf.convert_dict(orient='records')"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'to_dict'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'a':[1,1,1], 'b':[10,20,20]})) == [{'a': 1, 'b': 10}, {'a': 1, 'b': 20}, {'a': 1, 'b': 20}]\n    assert candidate(pd.DataFrame({'a':[2,1,1], 'b':[10,20,20]})) == [{'a': 2, 'b': 10}, {'a': 1, 'b': 20}, {'a': 1, 'b': 20}]\n    assert candidate(pd.DataFrame({'a':[2,1,4], 'b':[10,20,20]})) == [{'a': 2, 'b': 10}, {'a': 1, 'b': 20}, {'a': 4, 'b': 20}]\n    assert candidate(pd.DataFrame({'a':[2,3,4], 'b':[10,20,20]})) == [{'a': 2, 'b': 10}, {'a': 3, 'b': 20}, {'a': 4, 'b': 20}]\n    assert candidate(pd.DataFrame({'a':[2,3,4], 'b':[12,20,20]})) == [{'a': 2, 'b': 12}, {'a': 3, 'b': 20}, {'a': 4, 'b': 20}]\n    assert candidate(pd.DataFrame({'a':[2,3,4], 'b':[12,33,20]})) == [{'a': 2, 'b': 12}, {'a': 3, 'b': 33}, {'a': 4, 'b': 20}]\n    assert candidate(pd.DataFrame({'a':[2,3,4], 'b':[12,33,4]})) == [{'a': 2, 'b': 12}, {'a': 3, 'b': 33}, {'a': 4, 'b': 4}]\n    assert candidate(pd.DataFrame({'a':[2,3,41], 'b':[12,33,4]})) == [{'a': 2, 'b': 12}, {'a': 3, 'b': 33}, {'a': 41, 'b': 4}]\n    assert candidate(pd.DataFrame({'a':[2,33,41], 'b':[12,33,4]})) == [{'a': 2, 'b': 12}, {'a': 33, 'b': 33}, {'a': 41, 'b': 4}]\n    assert candidate(pd.DataFrame({'a':[21,33,41], 'b':[12,33,4]})) == [{'a': 21, 'b': 12}, {'a': 33, 'b': 33}, {'a': 41, 'b': 4}]\n\n"}
{"task_id": "PandasEval/57", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # getting(self, i): Return the element at specified position.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # length(self): Return the length of each Collections/Index element.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # stick(index, object, /): Place the object before the index.\n# # apd(object, /): Place the object at last position of the list.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # imaginary(val): Get the complex argument's imaginary part.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n\n# [end]\nimport monkey as mk\n\ndef convert_column_to_date(kf):\n    # Convert Column `Date` to Date Format using monkey function\n    # return the coverted knowledgeframe\n", "entry_point": "convert_column_to_date", "canonical_solution": ["    kf[\"Date\"] = mk.convert_datetime(kf.Date)\n    return kf"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'to_datetime'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame( {'Symbol':['A','A','A'] , 'Date':['02/20/2015','01/15/2016','08/21/2015']})).equals(pd.DataFrame({'Symbol':['A','A','A'] , 'Date':[pd.Timestamp('2015-02-20 00:00:00'),pd.Timestamp('2016-01-15 00:00:00'),pd.Timestamp('2015-08-21 00:00:00')]}))\n    assert candidate(pd.DataFrame( {'Symbol':['A','A','A'] , 'Date':['02/20/2016','01/15/2016','08/21/2015']})).equals(pd.DataFrame({'Symbol':['A','A','A'] , 'Date':[pd.Timestamp('2016-02-20 00:00:00'),pd.Timestamp('2016-01-15 00:00:00'),pd.Timestamp('2015-08-21 00:00:00')]}))\n    assert candidate(pd.DataFrame( {'Symbol':['A','A','A'] , 'Date':['02/20/2016','01/15/2017','08/21/2015']})).equals(pd.DataFrame({'Symbol':['A','A','A'] , 'Date':[pd.Timestamp('2016-02-20 00:00:00'),pd.Timestamp('2017-01-15 00:00:00'),pd.Timestamp('2015-08-21 00:00:00')]}))\n    assert candidate(pd.DataFrame( {'Symbol':['A','A','A'] , 'Date':['02/20/2016','01/15/2017','08/21/2019']})).equals(pd.DataFrame({'Symbol':['A','A','A'] , 'Date':[pd.Timestamp('2016-02-20 00:00:00'),pd.Timestamp('2017-01-15 00:00:00'),pd.Timestamp('2019-08-21 00:00:00')]}))\n\n\n"}
{"task_id": "PandasEval/60", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # length(self): Return the length of each Collections/Index element.\n# # getting(self, i): Return the element at specified position.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # apd(object, /): Place the object at last position of the list.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # stick(index, object, /): Place the object before the index.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n\n# [end]\nimport monkey as mk\n\ndef get_data_frame_from_list(list_of_lists):\n    # list_of_lists format: [header, [row1], [row2], ...]\n    # header format: [column1, column2, ...]\n    # row format: [value1, value2, ...]\n    # How to convert list to knowledgeframe?\n    # Return the knowledgeframe\n", "entry_point": "get_data_frame_from_list", "canonical_solution": ["    return mk.KnowledgeFrame(list_of_lists[1:], columns=list_of_lists[0])"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'DataFrame'\n}\n\n\ndef check(candidate):\n    assert candidate([['Heading1', 'Heading2'], [1 , 2], [3, 4]]).equals(pd.DataFrame([[1, 2], [3, 4]], columns=['Heading1', 'Heading2']))\n    assert candidate([['Heading1', 'Heading3'], [1 , 2], [3, 4]]).equals(pd.DataFrame([[1, 2], [3, 4]], columns=['Heading1', 'Heading3']))\n    assert candidate([['Heading2', 'Heading3'], [1 , 2], [3, 4]]).equals(pd.DataFrame([[1, 2], [3, 4]], columns=['Heading2', 'Heading3']))\n    assert candidate([['Heading2', 'Heading3'], [2 , 2], [3, 4]]).equals(pd.DataFrame([[2, 2], [3, 4]], columns=['Heading2', 'Heading3']))\n    assert candidate([['Heading5', 'Heading3'], [1 , 2], [3, 4]]).equals(pd.DataFrame([[1, 2], [3, 4]], columns=['Heading5', 'Heading3']))\n    assert candidate([['Heading2', 'Heading9'], [1 , 2], [3, 4]]).equals(pd.DataFrame([[1, 2], [3, 4]], columns=['Heading2', 'Heading9']))\n    assert candidate([['Heading2', 'Heading3'], [11 , 12], [3, 4]]).equals(pd.DataFrame([[11, 12], [3, 4]], columns=['Heading2', 'Heading3']))\n    assert candidate([['Heading22', 'Heading32'], [1 , 2], [3, 4]]).equals(pd.DataFrame([[1, 2], [3, 4]], columns=['Heading22', 'Heading32']))\n    assert candidate([['Heading2', 'Heading3'], [14 , 42], [3, 4]]).equals(pd.DataFrame([[14, 42], [3, 4]], columns=['Heading2', 'Heading3']))\n    assert candidate([['Heading2', 'Heading3'], [1 , 23], [33, 4]]).equals(pd.DataFrame([[1, 23], [33, 4]], columns=['Heading2', 'Heading3']))\n\n"}
{"task_id": "PandasEval/61", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # getting(self, i): Return the element at specified position.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # sqz(self, axis=None): Remove axes of length one.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n\n# [end]\nimport monkey as mk\n\nkf1 = mk.KnowledgeFrame({'a': [0, 1], 'b': [5, 3]})\nkf2 = mk.KnowledgeFrame({'c': [0, 1], 'd': [10, 20]})\n# How do I unioner two knowledgeframes by index?\n# Set left&right indexs to True\nunionerd_kf = ", "entry_point": "none", "canonical_solution": ["mk.unioner(kf1, kf2, left_index=True, right_index=True)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'merge'\n}\n\n\ndef check():\n    assert merged_result.equals(pd.merge(df1, df2, left_index=True, right_index=True))\n\n\n"}
{"task_id": "PandasEval/62", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # length(self): Return the length of each Collections/Index element.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # stick(index, object, /): Place the object before the index.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # apd(object, /): Place the object at last position of the list.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n\n# [end]\nimport monkey as mk\n\nkf = mk.KnowledgeFrame({'a': [0, 1], 'b': [5, 3]})\n# How to obtain monkey KnowledgeFrame without index\n# I want to print the whole knowledgeframe, but I don't want to print the index\nkf_string =", "entry_point": "none", "canonical_solution": [" kf.convert_string(index=False)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'to_string'\n}\n\n\ndef check():\n    assert df_string == ' a  b\n 0  5\n 1  3'\n\n\n"}
{"task_id": "PandasEval/63", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # length(self): Return the length of each Collections/Index element.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # stick(index, object, /): Place the object before the index.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # sqz(self, axis=None): Remove axes of length one.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n\n# [end]\nimport monkey as mk\nimport numpy as np\n\ndef sip_all_nan_rows(kf):\n    # We will sip all Nan rows.\n    # Return the changed knowledgeframe.\n", "entry_point": "drop_all_nan_rows", "canonical_solution": ["    return kf.sipna()"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'dropna'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [100, np.nan, np.nan], 'C': [2, np.nan, np.nan]})).equals(pd.DataFrame({'A': [1], 'B': [100.0], 'C': [2.0]}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [100, np.nan, np.nan], 'C': [4, np.nan, np.nan]})).equals(pd.DataFrame({'A': [1], 'B': [100.0], 'C': [4.0]}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [100, np.nan, np.nan], 'C': [6, np.nan, np.nan]})).equals(pd.DataFrame({'A': [1], 'B': [100.0], 'C': [6.0]}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [110, np.nan, np.nan], 'C': [6, np.nan, np.nan]})).equals(pd.DataFrame({'A': [1], 'B': [110.0], 'C': [6.0]}))\n    assert candidate(pd.DataFrame({'A': [2, 2, 3], 'B': [110, np.nan, np.nan], 'C': [6, np.nan, np.nan]})).equals(pd.DataFrame({'A': [2], 'B': [110.0], 'C': [6.0]}))\n    assert candidate(pd.DataFrame({'A': [22, 2, 3], 'B': [110, np.nan, np.nan], 'C': [6, np.nan, np.nan]})).equals(pd.DataFrame({'A': [22], 'B': [110.0], 'C': [6.0]}))\n    assert candidate(pd.DataFrame({'A': [22, 2, 33], 'B': [110, np.nan, np.nan], 'C': [6, np.nan, np.nan]})).equals(pd.DataFrame({'A': [22], 'B': [110.0], 'C': [6.0]}))\n    assert candidate(pd.DataFrame({'A': [22, 24, 33], 'B': [110, np.nan, np.nan], 'C': [6, np.nan, np.nan]})).equals(pd.DataFrame({'A': [22], 'B': [110.0], 'C': [6.0]}))\n    assert candidate(pd.DataFrame({'A': [22, 24, 52], 'B': [110, np.nan, np.nan], 'C': [6, np.nan, np.nan]})).equals(pd.DataFrame({'A': [22], 'B': [110.0], 'C': [6.0]}))\n    assert candidate(pd.DataFrame({'A': [22, 24, 13], 'B': [110, np.nan, np.nan], 'C': [6, np.nan, np.nan]})).equals(pd.DataFrame({'A': [22], 'B': [110.0], 'C': [6.0]}))\n\n\n"}
{"task_id": "PandasEval/64", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # getting(self, i): Return the element at specified position.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # stick(index, object, /): Place the object before the index.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # apd(object, /): Place the object at last position of the list.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n\n# [end]\nimport monkey as mk\n\ndef is_contain_particular_value(collections, value):\n    # How to determine whether a Monkey Column contains a particular value?\n    # Return the result\n", "entry_point": "is_contain_particular_value", "canonical_solution": ["    return value in collections.distinctive()"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'unique'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.Series([1, 2, 3]), 2) == True\n    assert candidate(pd.Series([1, 2, 3]), 3) == True\n    assert candidate(pd.Series([1, 2, 4]), 4) == True\n    assert candidate(pd.Series([1, 3, 4]), 4) == True\n    assert candidate(pd.Series([2, 3, 4]), 4) == True\n    assert candidate(pd.Series([2, 3, 4]), 5) == False\n    assert candidate(pd.Series([2, 3, 4]), 6) == False\n    assert candidate(pd.Series([2, 3, 4]), 7) == False\n    assert candidate(pd.Series([2, 3, 4]), 8) == False\n    assert candidate(pd.Series([2, 3, 4]), 0) == False\n\n\n"}
{"task_id": "PandasEval/65", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # getting(self, i): Return the element at specified position.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # length(self): Return the length of each Collections/Index element.\n# # # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n\n# [end]\nimport monkey as mk\n\ndef rename_column(kf, old_name, new_name):\n    # How would I rename the only one column header?\n    # return the changed knowledgeframe\n", "entry_point": "rename_column", "canonical_solution": ["    kf = kf.renaming(columns={old_name: new_name})\n    return kf"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'rename'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [100, 300, 500]}), 'A', 'D').equals(pd.DataFrame({'D': [1, 2, 3], 'B': [100, 300, 500]}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [21, 300, 500]}), 'A', 'D').equals(pd.DataFrame({'D': [1, 2, 3], 'B': [21, 300, 500]}))\n    assert candidate(pd.DataFrame({'A': [1, 3, 3], 'B': [21, 300, 500]}), 'A', 'D').equals(pd.DataFrame({'D': [1, 3, 3], 'B': [21, 300, 500]}))\n    assert candidate(pd.DataFrame({'A': [4, 3, 3], 'B': [21, 300, 500]}), 'A', 'D').equals(pd.DataFrame({'D': [4, 3, 3], 'B': [21, 300, 500]}))\n    assert candidate(pd.DataFrame({'A': [4, 3, 3], 'B': [21, 42, 500]}), 'A', 'D').equals(pd.DataFrame({'D': [4, 3, 3], 'B': [21, 42, 500]}))\n    assert candidate(pd.DataFrame({'A': [4, 3, 4], 'B': [21, 42, 500]}), 'A', 'D').equals(pd.DataFrame({'D': [4, 3, 4], 'B': [21, 42, 500]}))\n    assert candidate(pd.DataFrame({'A': [4, 3, 4], 'B': [21, 42, 32]}), 'A', 'D').equals(pd.DataFrame({'D': [4, 3, 4], 'B': [21, 42, 32]}))\n    assert candidate(pd.DataFrame({'A': [4, 4, 4], 'B': [21, 42, 32]}), 'A', 'D').equals(pd.DataFrame({'D': [4, 4, 4], 'B': [21, 42, 32]}))\n    assert candidate(pd.DataFrame({'A': [4, 4, 4], 'B': [21, 12, 32]}), 'A', 'D').equals(pd.DataFrame({'D': [4, 4, 4], 'B': [21, 12, 32]}))\n    assert candidate(pd.DataFrame({'A': [4, 4, 4], 'B': [21, 12, 21]}), 'A', 'D').equals(pd.DataFrame({'D': [4, 4, 4], 'B': [21, 12, 21]}))\n\n"}
{"task_id": "PandasEval/66", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # length(self): Return the length of each Collections/Index element.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # sqz(self, axis=None): Remove axes of length one.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n\n# [end]\nimport monkey as mk\n\ndef remove_duplicates_by_column(kf, col1, col2):\n    # I have a knowledgeframe with repeat values in column `col1`. I want to sip duplicates, keeping the row with the last value in column `col2`.\n    # How would I do that?\n    # return the final knowledgeframe\n", "entry_point": "remove_duplicates_by_column", "canonical_solution": ["    return kf.remove_duplicates(subset=col1, keep=\"last\")"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'drop_duplicates'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A': [1, 1, 3], 'B': [100, 300, 500]}), 'A', 'B').equals(pd.DataFrame({'A': [1, 3], 'B': [300, 500]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [1, 1, 3], 'B': [100, 350, 500]}), 'A', 'B').equals(pd.DataFrame({'A': [1, 3], 'B': [350, 500]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [1, 1, 3], 'B': [100, 350, 600]}), 'A', 'B').equals(pd.DataFrame({'A': [1, 3], 'B': [350, 600]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [1, 1, 3], 'B': [120, 350, 600]}), 'A', 'B').equals(pd.DataFrame({'A': [1, 3], 'B': [350, 600]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [1, 1, 3], 'B': [531, 350, 600]}), 'A', 'B').equals(pd.DataFrame({'A': [1, 3], 'B': [350, 600]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [1, 1, 3], 'B': [123, 350, 600]}), 'A', 'B').equals(pd.DataFrame({'A': [1, 3], 'B': [350, 600]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [1, 1, 3], 'B': [123, 125, 600]}), 'A', 'B').equals(pd.DataFrame({'A': [1, 3], 'B': [125, 600]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [1, 1, 3], 'B': [123, 125, 532]}), 'A', 'B').equals(pd.DataFrame({'A': [1, 3], 'B': [125, 532]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [1, 1, 3], 'B': [74, 125, 532]}), 'A', 'B').equals(pd.DataFrame({'A': [1, 3], 'B': [125, 532]}, index=[1, 2]))\n    assert candidate(pd.DataFrame({'A': [1, 1, 3], 'B': [74, 125, 45]}), 'A', 'B').equals(pd.DataFrame({'A': [1, 3], 'B': [125, 45]}, index=[1, 2]))\n\n\n"}
{"task_id": "PandasEval/67", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # apd(object, /): Place the object at last position of the list.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n\n# [end]\nimport monkey as mk\n\ndef create_empty_kf(col_names):\n    # Monkey create empty KnowledgeFrame with only column names\n    # Return: KnowledgeFrame\n", "entry_point": "create_empty_df", "canonical_solution": ["    return mk.KnowledgeFrame(columns=col_names)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'DataFrame'\n}\n\n\ndef check(candidate):\n    assert candidate(['A', 'B', 'C']).equals(pd.DataFrame(columns=['A', 'B', 'C']))\n    assert candidate(['A', 'd', 'C']).equals(pd.DataFrame(columns=['A', 'd', 'C']))\n    assert candidate(['A', 'B', 'E']).equals(pd.DataFrame(columns=['A', 'B', 'E']))\n    assert candidate(['A', 'Q', 'C']).equals(pd.DataFrame(columns=['A', 'Q', 'C']))\n    assert candidate(['X', 'B', 'C']).equals(pd.DataFrame(columns=['X', 'B', 'C']))\n    assert candidate(['A', 'B', 'N']).equals(pd.DataFrame(columns=['A', 'B', 'N']))\n    assert candidate(['A', 'G', 'C']).equals(pd.DataFrame(columns=['A', 'G', 'C']))\n    assert candidate(['T', 'B', 'C']).equals(pd.DataFrame(columns=['T', 'B', 'C']))\n    assert candidate(['A', 'S', 'C']).equals(pd.DataFrame(columns=['A', 'S', 'C']))\n    assert candidate(['A', 'B', 'V']).equals(pd.DataFrame(columns=['A', 'B', 'V']))\n\n\n"}
{"task_id": "PandasEval/69", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # getting(self, i): Return the element at specified position.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # apd(object, /): Place the object at last position of the list.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # imaginary(val): Get the complex argument's imaginary part.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n\n# [end]\nimport monkey as mk\n\ndef remove_duplicates_by_col_names(kf):\n    \"\"\"\n    Here's a one solution to remove columns based on duplicate column names:\n    Return the duplicated knowledgeframe\n    \"\"\"\n", "entry_point": "remove_duplicates_by_col_names", "canonical_solution": ["    return kf.loc[:,~kf.columns.duplicated_values()]"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'loc'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'B':list('abc')})).equals(pd.DataFrame({'A':[1,2,3], 'B':list('abc')}))\n    assert candidate(pd.DataFrame({'A':[1,2,4], 'B':[100,300,500], 'B':list('abc')})).equals(pd.DataFrame({'A':[1,2,4], 'B':list('abc')}))\n    assert candidate(pd.DataFrame({'A':[1,3,4], 'B':[100,300,500], 'B':list('abc')})).equals(pd.DataFrame({'A':[1,3,4], 'B':list('abc')}))\n    assert candidate(pd.DataFrame({'A':[1,3,4], 'B':[100,312,500], 'B':list('abc')})).equals(pd.DataFrame({'A':[1,3,4], 'B':list('abc')}))\n    assert candidate(pd.DataFrame({'A':[1,3,4], 'B':[100,312,213], 'B':list('abc')})).equals(pd.DataFrame({'A':[1,3,4], 'B':list('abc')}))\n    assert candidate(pd.DataFrame({'A':[1,3,4], 'B':[973,312,213], 'B':list('abc')})).equals(pd.DataFrame({'A':[1,3,4], 'B':list('abc')}))\n    assert candidate(pd.DataFrame({'A':[1,3,4], 'B':[973,312,111], 'B':list('abc')})).equals(pd.DataFrame({'A':[1,3,4], 'B':list('abc')}))\n    assert candidate(pd.DataFrame({'A':[1,3,4], 'C':[973,312,111], 'C':list('abc')})).equals(pd.DataFrame({'A':[1,3,4], 'C':list('abc')}))\n    assert candidate(pd.DataFrame({'A':[1,3,4], 'C':[973,312,122], 'C':list('abc')})).equals(pd.DataFrame({'A':[1,3,4], 'C':list('abc')}))\n    assert candidate(pd.DataFrame({'A':[1,3,4], 'C':[973,312,55], 'C':list('abc')})).equals(pd.DataFrame({'A':[1,3,4], 'C':list('abc')}))\n\n\n"}
{"task_id": "PandasEval/70", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # getting(self, i): Return the element at specified position.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # apd(object, /): Place the object at last position of the list.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n\n# [end]\nimport monkey as mk\n\ndef convert_bool_to_int(kf, col_name):\n    # How can I map True/False to 1/0 in a Monkey KnowledgeFrame?\n    # return the knowledgeframe with the column converted to int\n", "entry_point": "convert_bool_to_int", "canonical_solution": ["    kf[col_name] = kf[col_name].totype(int)\n    return kf"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'astype'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[True,True,False]}), 'B').equals(pd.DataFrame({'A':[1,2,3], 'B':[1,1,0]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[True,True,True]}), 'B').equals(pd.DataFrame({'A':[1,2,3], 'B':[1,1,1]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[True,False,False]}), 'B').equals(pd.DataFrame({'A':[1,2,3], 'B':[1,0,0]}))\n    assert candidate(pd.DataFrame({'A':[1,2,33], 'B':[True,True,False]}), 'B').equals(pd.DataFrame({'A':[1,2,33], 'B':[1,1,0]}))\n    assert candidate(pd.DataFrame({'A':[1,22,3], 'B':[True,True,False]}), 'B').equals(pd.DataFrame({'A':[1,22,3], 'B':[1,1,0]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[False,True,False]}), 'B').equals(pd.DataFrame({'A':[1,2,3], 'B':[0,1,0]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[False,False,False]}), 'B').equals(pd.DataFrame({'A':[1,2,3], 'B':[0,0,0]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[False,False,True]}), 'B').equals(pd.DataFrame({'A':[1,2,3], 'B':[0,0,1]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[True,False,True]}), 'B').equals(pd.DataFrame({'A':[1,2,3], 'B':[1,0,1]}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[True,True,True]}), 'B').equals(pd.DataFrame({'A':[1,2,3], 'B':[1,1,1]}))\n\n\n"}
{"task_id": "PandasEval/71", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # # length(self): Return the length of each Collections/Index element.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # sqz(self, axis=None): Remove axes of length one.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # stick(index, object, /): Place the object before the index.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # apd(object, /): Place the object at last position of the list.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n\n# [end]\nimport monkey as mk\n\ndef get_number_columns(kf):\n    # How do I retrieve the number of columns in a Monkey data frame?\n    # Return the number of columns in the knowledgeframe\n", "entry_point": "get_number_columns", "canonical_solution": ["    return length(kf.columns)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'len_columns'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({\"pear\": [1,2,3], \"apple\": [2,3,4], \"orange\": [3,4,5]})) == 3\n    assert candidate(pd.DataFrame({'pear': [1,2,3], 'apple': [2,3,4]})) == 2\n    assert candidate(pd.DataFrame({'pear': [1,2,3], 'apple': [2,3,5]})) == 2\n    assert candidate(pd.DataFrame({'pear': [1,4,3], 'apple': [2,3,4]})) == 2\n    assert candidate(pd.DataFrame({'pear': [3,2,3], 'apple': [2,3,4]})) == 2\n    assert candidate(pd.DataFrame({'pear': [1,2,3], 'apple': [2,3,5]})) == 2\n    assert candidate(pd.DataFrame({'pear': [1,2,3]})) == 1\n    assert candidate(pd.DataFrame({'pear': [11,2,3], 'apple': [2,3,4]})) == 2\n    assert candidate(pd.DataFrame({'pear': [1,2,3], 'apple': [2,412,4]})) == 2\n    assert candidate(pd.DataFrame({'pear': [1,2,3], 'apple': [22,33,44]})) == 2\n\n\n"}
{"task_id": "PandasEval/73", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # getting(self, i): Return the element at specified position.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # length(self): Return the length of each Collections/Index element.\n# # # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n\n# [end]\nimport monkey as mk\n\nN = 2\nkf = mk.KnowledgeFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6], \"c\": [7, 8, 9]})\n# How to get the last N rows of a monkey KnowledgeFrame?\nresult = ", "entry_point": "none", "canonical_solution": ["kf.last_tail(N)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'tail'\n}\n\n\ndef check():\n    assert result.equals(df.tail(N))\n\n\n"}
{"task_id": "PandasEval/74", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # length(self): Return the length of each Collections/Index element.\n# # # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # sqz(self, axis=None): Remove axes of length one.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n\n# [end]\nimport monkey as mk\nimport numpy as np\n\ndef replacing_blank_with_nan(kf):\n    # replace field that's entirely space (or empty) with NaN using regex\n    # return the result\n", "entry_point": "replacing_blank_with_nan", "canonical_solution": ["    return kf.replacing(r'^\\s*$', np.nan, regex=True)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'replace'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'a': [1.0, 2.0, ' '], 'b': [4.0, 5.0, 6.0]})).astype(np.float).equals(pd.DataFrame({'a': [1.0, 2.0, np.nan], 'b': [4.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [2.0, 2.0, ' '], 'b': [4.0, 5.0, 6.0]})).astype(np.float).equals(pd.DataFrame({'a': [2.0, 2.0, np.nan], 'b': [4.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [2.0, 2.0, ' '], 'b': [1.0, 5.0, 6.0]})).astype(np.float).equals(pd.DataFrame({'a': [2.0, 2.0, np.nan], 'b': [1.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [2.0, 2.0, ' '], 'b': [4.0, 15.0, 6.0]})).astype(np.float).equals(pd.DataFrame({'a': [2.0, 2.0, np.nan], 'b': [4.0, 15.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [2.0, 4.0, ' '], 'b': [4.0, 5.0, 6.0]})).astype(np.float).equals(pd.DataFrame({'a': [2.0, 4.0, np.nan], 'b': [4.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [2.0, 2.0, ' '], 'b': [4.0, 15.0, 16.0]})).astype(np.float).equals(pd.DataFrame({'a': [2.0, 2.0, np.nan], 'b': [4.0, 15.0, 16.0]}))\n    assert candidate(pd.DataFrame({'a': [2.0, 2.0, ' '], 'b': [14.0, 15.0, 6.0]})).astype(np.float).equals(pd.DataFrame({'a': [2.0, 2.0, np.nan], 'b': [14.0, 15.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [21.0, 12.0, ' '], 'b': [4.0, 5.0, 6.0]})).astype(np.float).equals(pd.DataFrame({'a': [21.0, 12.0, np.nan], 'b': [4.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [2.0, 2.0, ' '], 'b': [24.0, 25.0, 6.0]})).astype(np.float).equals(pd.DataFrame({'a': [2.0, 2.0, np.nan], 'b': [24.0, 25.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [2.0, ' ', ' '], 'b': [4.0, 5.0, 6.0]})).astype(np.float).equals(pd.DataFrame({'a': [2.0, np.nan , np.nan], 'b': [4.0, 5.0, 6.0]}))\n\n"}
{"task_id": "PandasEval/75", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n\n# [end]\nimport monkey as mk\nimport numpy as np\n\ndef fill_none_with_zero(kf, col_names):\n    # Monkey knowledgeframe fillnone() only some columns in place\n    # This function fills all columns with 0\n    # Return the changed knowledgeframe\n", "entry_point": "fill_none_with_zero", "canonical_solution": ["    kf[col_names] = kf[col_names].fillnone(0)\n    return kf"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'fillna'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'a': [1.0, 2.0, None], 'b': [4.0, 5.0, 6.0]}), ['a']).equals(pd.DataFrame({'a': [1.0, 2.0, 0.0], 'b': [4.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [1.0, 2.0, None], 'b': [4.0, 5.0, 6.0]}), ['b']).equals(pd.DataFrame({'a': [1.0, 2.0, None], 'b': [4.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [1.0, 2.0, None], 'b': [4.0, 5.0, 6.0]}), ['a', 'b']).equals(pd.DataFrame({'a': [1.0, 2.0, 0.0], 'b': [4.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [4.0, 2.0, None], 'b': [4.0, 5.0, 6.0]}), ['a', 'b']).equals(pd.DataFrame({'a': [4.0, 2.0, 0.0], 'b': [4.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [1.0, 4.0, None], 'b': [4.0, 5.0, 6.0]}), ['a', 'b']).equals(pd.DataFrame({'a': [1.0, 4.0, 0.0], 'b': [4.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [1.0, 2.0, None], 'b': [42.0, 5.0, 6.0]}), ['a', 'b']).equals(pd.DataFrame({'a': [1.0, 2.0, 0.0], 'b': [42.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [1.0, 2.0, None], 'b': [4.0, 52.0, 62.0]}), ['a', 'b']).equals(pd.DataFrame({'a': [1.0, 2.0, 0.0], 'b': [4.0, 52.0, 62.0]}))\n    assert candidate(pd.DataFrame({'a': [11.0, 21.0, None], 'b': [4.0, 5.0, 6.0]}), ['a', 'b']).equals(pd.DataFrame({'a': [11.0, 21.0, 0.0], 'b': [4.0, 5.0, 6.0]}))\n    assert candidate(pd.DataFrame({'a': [1.0, 2.0, None], 'b': [4.0, 15.0, 16.0]}), ['a', 'b']).equals(pd.DataFrame({'a': [1.0, 2.0, 0.0], 'b': [4.0, 15.0, 16.0]}))\n    assert candidate(pd.DataFrame({'a': [1.0, 23.0, None], 'b': [43.0, 5.0, 6.0]}), ['a', 'b']).equals(pd.DataFrame({'a': [1.0, 23.0, 0.0], 'b': [43.0, 5.0, 6.0]}))\n\n\n"}
{"task_id": "PandasEval/76", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # length(self): Return the length of each Collections/Index element.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # sqz(self, axis=None): Remove axes of length one.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n\n# [end]\nimport monkey as mk\n\ndef concating_kf(kf1, kf2):\n    # Given that all the knowledgeframes have the same columns, you can simply concat them:\n    # return the concated knowledgeframe\n", "entry_point": "concat_df", "canonical_solution": ["    return mk.concating([kf1, kf2])"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'concat'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'a': [1, 2], 'b': [4, 2]}), pd.DataFrame({'a': [6, 7], 'b': [9, 6]})).equals(pd.DataFrame({'a': [1, 2, 6, 7], 'b': [4, 2, 9, 6]}, index=[0, 1, 0, 1]))\n    assert candidate(pd.DataFrame({'a': [1, 3], 'b': [4, 2]}), pd.DataFrame({'a': [6, 7], 'b': [9, 6]})).equals(pd.DataFrame({'a': [1, 3, 6, 7], 'b': [4, 2, 9, 6]}, index=[0, 1, 0, 1]))\n    assert candidate(pd.DataFrame({'a': [1, 3], 'b': [43, 2]}), pd.DataFrame({'a': [6, 7], 'b': [9, 6]})).equals(pd.DataFrame({'a': [1, 3, 6, 7], 'b': [43, 2, 9, 6]}, index=[0, 1, 0, 1]))\n    assert candidate(pd.DataFrame({'a': [1, 3], 'b': [43, 32]}), pd.DataFrame({'a': [6, 7], 'b': [9, 6]})).equals(pd.DataFrame({'a': [1, 3, 6, 7], 'b': [43, 32, 9, 6]}, index=[0, 1, 0, 1]))\n    assert candidate(pd.DataFrame({'a': [1, 3], 'b': [43, 32]}), pd.DataFrame({'a': [62, 7], 'b': [9, 6]})).equals(pd.DataFrame({'a': [1, 3, 62, 7], 'b': [43, 32, 9, 6]}, index=[0, 1, 0, 1]))\n    assert candidate(pd.DataFrame({'a': [1, 333], 'b': [43, 32]}), pd.DataFrame({'a': [62, 7], 'b': [9, 6]})).equals(pd.DataFrame({'a': [1, 333, 62, 7], 'b': [43, 32, 9, 6]}, index=[0, 1, 0, 1]))\n    assert candidate(pd.DataFrame({'a': [1, 3], 'b': [43, 32]}), pd.DataFrame({'a': [62, 7], 'b': [9, 66]})).equals(pd.DataFrame({'a': [1, 3, 62, 7], 'b': [43, 32, 9, 66]}, index=[0, 1, 0, 1]))\n    assert candidate(pd.DataFrame({'a': [1, 3], 'b': [43, 32]}), pd.DataFrame({'a': [62, 7], 'b': [99, 6]})).equals(pd.DataFrame({'a': [1, 3, 62, 7], 'b': [43, 32, 99, 6]}, index=[0, 1, 0, 1]))\n    assert candidate(pd.DataFrame({'a': [1, 3], 'b': [43, 32]}), pd.DataFrame({'a': [62, 77], 'b': [9, 6]})).equals(pd.DataFrame({'a': [1, 3, 62, 77], 'b': [43, 32, 9, 6]}, index=[0, 1, 0, 1]))\n    assert candidate(pd.DataFrame({'a': [1, 3], 'b': [43, 32]}), pd.DataFrame({'a': [62, 70], 'b': [9, 6]})).equals(pd.DataFrame({'a': [1, 3, 62, 70], 'b': [43, 32, 9, 6]}, index=[0, 1, 0, 1]))\n\n\n"}
{"task_id": "PandasEval/79", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # length(self): Return the length of each Collections/Index element.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # # convert_list(self, *args, **kwargs): Create a list with the passed values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # apd(object, /): Place the object at last position of the list.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # sqz(self, axis=None): Remove axes of length one.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n\n# [end]\nimport monkey as mk\n\ndef get_row_index_values_as_list(kf):\n    # Return the row-index values of the knowledgeframe as a list\n", "entry_point": "get_row_index_values_as_list", "canonical_solution": ["    return kf.index.values.convert_list()"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'tolist',\n    'type': 'isna_any'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'a': [2, 3, 2], 'b': [4, 4, 2]})) == [0, 1, 2]\n    assert candidate(pd.DataFrame({'a': [2, 5, 2], 'b': [4, 4, 2]})) == [0, 1, 2]\n    assert candidate(pd.DataFrame({'a': [2, 8, 2], 'b': [4, 4, 2]})) == [0, 1, 2]\n    assert candidate(pd.DataFrame({'a': [2, 10, 2], 'b': [4, 4, 2]})) == [0, 1, 2]\n    assert candidate(pd.DataFrame({'a': [2, 10, 2], 'b': [4, 4, 2]}, index=[1, 0 ,2])) == [1, 0, 2]\n    assert candidate(pd.DataFrame({'a': [2, 10, 2], 'b': [4, 412, 2]}, index=[1, 0 ,2])) == [1, 0, 2]\n    assert candidate(pd.DataFrame({'a': [21, 110, 2], 'b': [4, 4, 2]}, index=[1, 0 ,2])) == [1, 0, 2]\n    assert candidate(pd.DataFrame({'a': [2, 10, 2], 'b': [4, 4, 21]}, index=[1, 0 ,21])) == [1, 0, 21]\n    assert candidate(pd.DataFrame({'a': [2, 110, 12], 'b': [4, 4, 2]}, index=[1, 0 ,2])) == [1, 0, 2]\n    assert candidate(pd.DataFrame({'a': [32, 310, 2], 'b': [4, 4, 2]}, index=[1, 0 ,2])) == [1, 0, 2]\n\n\n"}
{"task_id": "PandasEval/80", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # getting(self, i): Return the element at specified position.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # sqz(self, axis=None): Remove axes of length one.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # apd(object, /): Place the object at last position of the list.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n\n# [end]\nimport monkey as mk\nimport numpy as np\n\nkf = mk.KnowledgeFrame({'mycol':np.arange(5), 'dummy':np.arange(5)})\n# I find myself often having to check whether a column or row exists in a knowledgeframe before trying to reference it.\n# Is there any way to do this more nicely? \n# For example on an arbitrary object I can do x = getattr(anobject, 'id', default) - is there anything similar to this in monkey? Really any way to achieve what I'm doing more gracefully?\n# Output the second row of data in `mycol` column if it exists, otherwise output NaN\nvalue =", "entry_point": "none", "canonical_solution": [" kf.mycol.getting(1, np.nan)", " kf.loc[1, 'mycol'] if 1 in kf.index else np.nan"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'get_index'\n}\n\n\ndef check():\n    assert value == 1\n\n\n"}
{"task_id": "PandasEval/81", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # length(self): Return the length of each Collections/Index element.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # getting(self, i): Return the element at specified position.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n\n# [end]\nimport monkey as mk\n\ndef counting_occurrences_of_a_value(collections, value):\n    # Count the number of occurrences of a value in a collections\n    # Return the count\n", "entry_point": "counting_occurrences_of_a_value", "canonical_solution": ["    return collections.counts_value_num()[value]"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'value_counts'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.Series([1, 2, 3, 1, 2, 3, 1, 2, 3]), 1) == 3\n    assert candidate(pd.Series([1, 2, 3, 1, 1, 3, 1, 2, 3]), 1) == 4\n    assert candidate(pd.Series([1, 4, 3, 1, 1, 3, 1, 2, 3]), 1) == 4\n    assert candidate(pd.Series([1, 2, 3, 1, 1, 35, 1, 2, 3]), 1) == 4\n    assert candidate(pd.Series([1, 2, 13, 1, 1, 3, 1, 12, 3]), 1) == 4\n    assert candidate(pd.Series([11, 2, 3, 1, 1, 3, 1, 2, 3]), 1) == 3\n    assert candidate(pd.Series([1, 2, 3, 1, 1, 43, 1, 42, 35]), 1) == 4\n    assert candidate(pd.Series([1, 2, 3, 1, 1, 3, 1, 2, 3]), 2) == 2\n    assert candidate(pd.Series([1, 2, 3, 1, 1, 3, 1, 2, 3]), 3) == 3\n    assert candidate(pd.Series([1, 2, 3, 1, 1, 3, 1, 2, 33]), 33) == 1\n\n"}
{"task_id": "PandasEval/83", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # apd(object, /): Place the object at last position of the list.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # sqz(self, axis=None): Remove axes of length one.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n\n# [end]\nimport monkey as mk\n\ndef sip_consecutive_duplicates(collections):\n    # Drop consecutive duplicates\n    # Return the result\n", "entry_point": "drop_consecutive_duplicates", "canonical_solution": ["    return collections.loc[collections.shifting(-1) != collections]"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'loc'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.Series([1, 2, 2, 3, 2])).equals(pd.Series([1, 2, 3, 2], index=[0, 2, 3, 4]))\n    assert candidate(pd.Series([1, 2, 2, 4, 2])).equals(pd.Series([1, 2, 4, 2], index=[0, 2, 3, 4]))\n    assert candidate(pd.Series([1, 2, 2, 5, 2])).equals(pd.Series([1, 2, 5, 2], index=[0, 2, 3, 4]))\n    assert candidate(pd.Series([1, 2, 2, 6, 2])).equals(pd.Series([1, 2, 6, 2], index=[0, 2, 3, 4]))\n    assert candidate(pd.Series([1, 2, 2, 7, 2])).equals(pd.Series([1, 2, 7, 2], index=[0, 2, 3, 4]))\n    assert candidate(pd.Series([1, 2, 2, 8, 2])).equals(pd.Series([1, 2, 8, 2], index=[0, 2, 3, 4]))\n    assert candidate(pd.Series([1, 2, 2, 9, 2])).equals(pd.Series([1, 2, 9, 2], index=[0, 2, 3, 4]))\n    assert candidate(pd.Series([1, 2, 2, 10, 2])).equals(pd.Series([1, 2, 10, 2], index=[0, 2, 3, 4]))\n    assert candidate(pd.Series([1, 2, 2, 11, 2])).equals(pd.Series([1, 2, 11, 2], index=[0, 2, 3, 4]))\n    assert candidate(pd.Series([1, 2, 2, 13, 2])).equals(pd.Series([1, 2, 13, 2], index=[0, 2, 3, 4]))\n\n\n"}
{"task_id": "PandasEval/84", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # apd(object, /): Place the object at last position of the list.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # stick(index, object, /): Place the object before the index.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n\n# [end]\nimport monkey as mk\n\ndef value_round_a_single_column(kf):\n    # Round a single column `A`\n    # Return the knowledgeframe\n", "entry_point": "round_a_single_column", "canonical_solution": ["    kf.A = kf.A.value_round()\n    return kf"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'round'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A': [1.23, 2.34, 3.45], 'B': [4.56, 5.67, 6.78]})).equals(pd.DataFrame({'A': [1.0, 2.0, 3.0], 'B': [4.56, 5.67, 6.78]}))\n    assert candidate(pd.DataFrame({'A': [1.41, 2.34, 3.45], 'B': [4.56, 5.67, 6.78]})).equals(pd.DataFrame({'A': [1.0, 2.0, 3.0], 'B': [4.56, 5.67, 6.78]}))\n    assert candidate(pd.DataFrame({'A': [1.41, 2.36, 3.45], 'B': [4.56, 5.67, 6.78]})).equals(pd.DataFrame({'A': [1.0, 2.0, 3.0], 'B': [4.56, 5.67, 6.78]}))\n    assert candidate(pd.DataFrame({'A': [1.41, 2.36, 3.55], 'B': [4.56, 5.67, 6.78]})).equals(pd.DataFrame({'A': [1.0, 2.0, 4.0], 'B': [4.56, 5.67, 6.78]}))\n    assert candidate(pd.DataFrame({'A': [1.41, 2.56, 3.55], 'B': [4.56, 5.67, 6.78]})).equals(pd.DataFrame({'A': [1.0, 3.0, 4.0], 'B': [4.56, 5.67, 6.78]}))\n    assert candidate(pd.DataFrame({'A': [1.31, 2.56, 3.55], 'B': [4.56, 5.67, 6.78]})).equals(pd.DataFrame({'A': [1.0, 3.0, 4.0], 'B': [4.56, 5.67, 6.78]}))\n    assert candidate(pd.DataFrame({'A': [1.31, 1.56, 3.55], 'B': [4.56, 5.67, 6.78]})).equals(pd.DataFrame({'A': [1.0, 2.0, 4.0], 'B': [4.56, 5.67, 6.78]}))\n    assert candidate(pd.DataFrame({'A': [1.31, 1.56, 3.55], 'B': [4.56, 3.67, 6.78]})).equals(pd.DataFrame({'A': [1.0, 2.0, 4.0], 'B': [4.56, 3.67, 6.78]}))\n    assert candidate(pd.DataFrame({'A': [1.31, 1.56, 4.15], 'B': [4.56, 3.67, 6.78]})).equals(pd.DataFrame({'A': [1.0, 2.0, 4.0], 'B': [4.56, 3.67, 6.78]}))\n    assert candidate(pd.DataFrame({'A': [1.31, 1.56, 4.05], 'B': [4.56, 3.67, 6.78]})).equals(pd.DataFrame({'A': [1.0, 2.0, 4.0], 'B': [4.56, 3.67, 6.78]}))\n\n\n"}
{"task_id": "PandasEval/86", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # length(self): Return the length of each Collections/Index element.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # apd(object, /): Place the object at last position of the list.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # sqz(self, axis=None): Remove axes of length one.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n\n# [end]\nimport monkey as mk\n\ndef adding_dict_to_kf(kf, dictionary):\n    # adding dictionary to data frame\n    # return the data frame\n", "entry_point": "append_dict_to_df", "canonical_solution": ["    kf = kf.adding(dictionary, ignore_index=True)\n    return kf"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'append'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame(), {'B': 100, 'C': 200}).equals(pd.DataFrame({'B': [100.0], 'C': [200.0]}))\n    assert candidate(pd.DataFrame(), {'B': 110, 'C': 200}).equals(pd.DataFrame({'B': [110.0], 'C': [200.0]}))\n    assert candidate(pd.DataFrame(), {'B': 120, 'C': 200}).equals(pd.DataFrame({'B': [120.0], 'C': [200.0]}))\n    assert candidate(pd.DataFrame(), {'B': 150, 'C': 200}).equals(pd.DataFrame({'B': [150.0], 'C': [200.0]}))\n    assert candidate(pd.DataFrame(), {'B': 150, 'C': 220}).equals(pd.DataFrame({'B': [150.0], 'C': [220.0]}))\n    assert candidate(pd.DataFrame(), {'B': 154, 'C': 220}).equals(pd.DataFrame({'B': [154.0], 'C': [220.0]}))\n    assert candidate(pd.DataFrame(), {'B': 164, 'C': 220}).equals(pd.DataFrame({'B': [164.0], 'C': [220.0]}))\n    assert candidate(pd.DataFrame(), {'B': 164, 'C': 240}).equals(pd.DataFrame({'B': [164.0], 'C': [240.0]}))\n    assert candidate(pd.DataFrame(), {'B': 164, 'C': 244}).equals(pd.DataFrame({'B': [164.0], 'C': [244.0]}))\n    assert candidate(pd.DataFrame(), {'B': 184, 'C': 244}).equals(pd.DataFrame({'B': [184.0], 'C': [244.0]}))\n\n\n"}
{"task_id": "PandasEval/87", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # getting(self, i): Return the element at specified position.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # length(self): Return the length of each Collections/Index element.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # sqz(self, axis=None): Remove axes of length one.\n# # apd(object, /): Place the object at last position of the list.\n\n# [end]\nimport monkey as mk\n\ndef transform_timestamp_to_pydatetime(timestamp):\n    # transform timestamp to pydatetime object\n    # return pydatetime object\n", "entry_point": "transform_timestamp_to_pydatetime", "canonical_solution": ["    return timestamp.convert_pydatetime()"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'to_pydatetime'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.Timestamp('2019-01-01')) == pd.Timestamp('2019-01-01').to_pydatetime()\n    assert candidate(pd.Timestamp('2022-01-01')) == pd.Timestamp('2022-01-01').to_pydatetime()\n    assert candidate(pd.Timestamp('2022-03-01')) == pd.Timestamp('2022-03-01').to_pydatetime()\n    assert candidate(pd.Timestamp('2022-03-04')) == pd.Timestamp('2022-03-04').to_pydatetime()\n    assert candidate(pd.Timestamp('2022-02-01')) == pd.Timestamp('2022-02-01').to_pydatetime()\n    assert candidate(pd.Timestamp('2022-02-09')) == pd.Timestamp('2022-02-09').to_pydatetime()\n    assert candidate(pd.Timestamp('2022-03-12')) == pd.Timestamp('2022-03-12').to_pydatetime()\n    assert candidate(pd.Timestamp('2022-03-16')) == pd.Timestamp('2022-03-16').to_pydatetime()\n    assert candidate(pd.Timestamp('2022-02-28')) == pd.Timestamp('2022-02-28').to_pydatetime()\n    assert candidate(pd.Timestamp('2021-02-28')) == pd.Timestamp('2021-02-28').to_pydatetime()\n\n\n"}
{"task_id": "PandasEval/88", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # getting(self, i): Return the element at specified position.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # length(self): Return the length of each Collections/Index element.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # apd(object, /): Place the object at last position of the list.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # sqz(self, axis=None): Remove axes of length one.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n\n# [end]\nimport monkey as mk\n\ndef getting_percentage_of_each_gender(collections):\n    # Given a monkey collections that represents frequencies of a value, how can I turn those frequencies into percentages?\n    # Return the percentage of each gender.\n", "entry_point": "get_percentage_of_each_gender", "canonical_solution": ["    return collections.counts_value_num(normalize=True)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'value_counts'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'sex': ['male'] * 5 + ['female'] * 3}).sex).equals(pd.DataFrame({'sex': ['male'] * 5 + ['female'] * 3}).sex.value_counts(normalize=True))\n    assert candidate(pd.DataFrame({'sex': ['male'] * 4 + ['female'] * 3}).sex).equals(pd.DataFrame({'sex': ['male'] * 4 + ['female'] * 3}).sex.value_counts(normalize=True))\n    assert candidate(pd.DataFrame({'sex': ['male'] * 6 + ['female'] * 3}).sex).equals(pd.DataFrame({'sex': ['male'] * 6 + ['female'] * 3}).sex.value_counts(normalize=True))\n    assert candidate(pd.DataFrame({'sex': ['male'] * 5 + ['female'] * 1}).sex).equals(pd.DataFrame({'sex': ['male'] * 5 + ['female'] * 1}).sex.value_counts(normalize=True))\n    assert candidate(pd.DataFrame({'sex': ['male'] * 2 + ['female'] * 3}).sex).equals(pd.DataFrame({'sex': ['male'] * 2 + ['female'] * 3}).sex.value_counts(normalize=True))\n    assert candidate(pd.DataFrame({'sex': ['male'] * 4 + ['female'] * 13}).sex).equals(pd.DataFrame({'sex': ['male'] * 4 + ['female'] * 13}).sex.value_counts(normalize=True))\n    assert candidate(pd.DataFrame({'sex': ['male'] * 15 + ['female'] * 13}).sex).equals(pd.DataFrame({'sex': ['male'] * 15 + ['female'] * 13}).sex.value_counts(normalize=True))\n    assert candidate(pd.DataFrame({'sex': ['male'] * 43 + ['female'] * 3}).sex).equals(pd.DataFrame({'sex': ['male'] * 43 + ['female'] * 3}).sex.value_counts(normalize=True))\n    assert candidate(pd.DataFrame({'sex': ['male'] * 53 + ['female'] * 33}).sex).equals(pd.DataFrame({'sex': ['male'] * 53 + ['female'] * 33}).sex.value_counts(normalize=True))\n    assert candidate(pd.DataFrame({'sex': ['male'] * 25 + ['female'] * 32}).sex).equals(pd.DataFrame({'sex': ['male'] * 25 + ['female'] * 32}).sex.value_counts(normalize=True))\n\n\n"}
{"task_id": "PandasEval/89", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # getting(self, i): Return the element at specified position.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # imaginary(val): Get the complex argument's imaginary part.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # sqz(self, axis=None): Remove axes of length one.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # stick(index, object, /): Place the object before the index.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n\n# [end]\nimport monkey as mk\n\ndef  divide_multiple_cols_by_first_col(kf):\n    # I need to  divide all ['B','C'] columns but the first column 'A' in a KnowledgeFrame by the first column.\n    # Return the result.\n", "entry_point": "divide_multiple_cols_by_first_col", "canonical_solution": ["    kf[['B','C']] = kf[['B','C']]. division(kf.A, axis=0)\n    return kf"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'div'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A':[1,3,5], 'B':[10,30,50], 'C':[100,300,500]})).equals(pd.DataFrame({'A':[1,3,5], 'B':[10.0, 10.0, 10.0], 'C':[100.0, 100.0, 100.0]}))\n    assert candidate(pd.DataFrame({'A':[1,3], 'B':[10,30], 'C':[100,300]})).equals(pd.DataFrame({'A':[1,3], 'B':[10.0, 10.0], 'C':[100.0, 100.0]}))\n\n\n"}
{"task_id": "PandasEval/90", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # getting(self, i): Return the element at specified position.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # stick(index, object, /): Place the object before the index.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # apd(object, /): Place the object at last position of the list.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n\n# [end]\nimport monkey as mk\nimport numpy as np\ndef ceiling_of_collections(s):\n    # ceiling of a monkey collections\n    # Return the result.\n", "entry_point": "ceil_of_series", "canonical_solution": ["    return np.ceiling(s)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'ceil'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.Series([1.2, 2.3, 3.4, 4.5, 5.6])).equals(pd.Series([2, 3, 4, 5, 6]).astype(float))\n    assert candidate(pd.Series([1.1, 2.3, 3.4, 4.5, 5.6])).equals(pd.Series([2, 3, 4, 5, 6]).astype(float))\n    assert candidate(pd.Series([1.2, 2.4, 3.4, 4.5, 5.6])).equals(pd.Series([2, 3, 4, 5, 6]).astype(float))\n    assert candidate(pd.Series([1.2, 2.3, 3.2, 4.5, 5.6])).equals(pd.Series([2, 3, 4, 5, 6]).astype(float))\n    assert candidate(pd.Series([1.2, 2.3, 3.4, 4.2, 5.6])).equals(pd.Series([2, 3, 4, 5, 6]).astype(float))\n    assert candidate(pd.Series([1.2, 2.3, 3.4, 4.5, 5.1])).equals(pd.Series([2, 3, 4, 5, 6]).astype(float))\n    assert candidate(pd.Series([1.2, 2.3, 3.4, 4.4, 5.6])).equals(pd.Series([2, 3, 4, 5, 6]).astype(float))\n    assert candidate(pd.Series([1.2, 2.3, 3.4, 4.5, 5.2])).equals(pd.Series([2, 3, 4, 5, 6]).astype(float))\n    assert candidate(pd.Series([1.4, 2.3, 3.4, 4.5, 5.6])).equals(pd.Series([2, 3, 4, 5, 6]).astype(float))\n    assert candidate(pd.Series([1.2, 2.1, 3.4, 4.1, 5.6])).equals(pd.Series([2, 3, 4, 5, 6]).astype(float))\n\n"}
{"task_id": "PandasEval/91", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # stick(index, object, /): Place the object before the index.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # apd(object, /): Place the object at last position of the list.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n\n# [end]\nimport monkey as mk\nimport numpy as np\n\ndef delete_all_nan_columns(kf):\n    # Delete all columns that contain all NaN values\n    # Return the result.\n", "entry_point": "delete_all_nan_columns", "canonical_solution": ["    return kf.sipna(how='all', axis=1)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'dropna'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [np.nan, np.nan, np.nan], 'C': [np.nan, np.nan, np.nan]})).equals(pd.DataFrame({'A': [1, 2, 3]}))\n    assert candidate(pd.DataFrame({'A': [1, 3, 3], 'B': [np.nan, np.nan, np.nan], 'C': [np.nan, np.nan, np.nan]})).equals(pd.DataFrame({'A': [1, 3, 3]}))\n    assert candidate(pd.DataFrame({'A': [4, 2, 3], 'B': [np.nan, np.nan, np.nan], 'C': [np.nan, np.nan, np.nan]})).equals(pd.DataFrame({'A': [4, 2, 3]}))\n    assert candidate(pd.DataFrame({'A': [6, 2, 3], 'B': [np.nan, np.nan, np.nan], 'C': [np.nan, np.nan, np.nan]})).equals(pd.DataFrame({'A': [6, 2, 3]}))\n    assert candidate(pd.DataFrame({'A': [1, 12, 3], 'B': [np.nan, np.nan, np.nan], 'C': [np.nan, np.nan, np.nan]})).equals(pd.DataFrame({'A': [1, 12, 3]}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 33], 'B': [np.nan, np.nan, np.nan], 'C': [np.nan, np.nan, np.nan]})).equals(pd.DataFrame({'A': [1, 2, 33]}))\n    assert candidate(pd.DataFrame({'A': [13, 23, 3], 'B': [np.nan, np.nan, np.nan], 'C': [np.nan, np.nan, np.nan]})).equals(pd.DataFrame({'A': [13, 23, 3]}))\n    assert candidate(pd.DataFrame({'A': [1, 25, 35], 'B': [np.nan, np.nan, np.nan], 'C': [np.nan, np.nan, np.nan]})).equals(pd.DataFrame({'A': [1, 25, 35]}))\n    assert candidate(pd.DataFrame({'A': [41, 2, 3], 'B': [np.nan, np.nan, np.nan], 'C': [np.nan, np.nan, np.nan]})).equals(pd.DataFrame({'A': [41, 2, 3]}))\n    assert candidate(pd.DataFrame({'A': [1, 24, 3], 'B': [np.nan, np.nan, np.nan], 'C': [np.nan, np.nan, np.nan]})).equals(pd.DataFrame({'A': [1, 24, 3]}))\n\n\n"}
{"task_id": "PandasEval/92", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # length(self): Return the length of each Collections/Index element.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # getting(self, i): Return the element at specified position.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # sqz(self, axis=None): Remove axes of length one.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n\n# [end]\nimport monkey as mk\n\nkf = mk.KnowledgeFrame({'name': ['jon','sam','jane','bob'],\n           'age': [30,25,18,26],\n           'sex':['male','male','female','male']})\n\nrow = ['45', 'Dean', 'male']\n# add the row at top in kf\nkf.loc[-1] = row\nkf.index = kf.index + 1\n# resort the index by inplace\n", "entry_point": "none", "canonical_solution": ["kf.sorting_index(inplace=True)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'dropna'\n}\n\n\ndef check():\n    assert df.equals(pd.DataFrame({'name': ['Dean', 'jon','sam','jane','bob'], 'age': [45, 30,25,18,26], 'sex':['male', 'male','male','female','male']}))\n\n\n"}
{"task_id": "PandasEval/93", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # length(self): Return the length of each Collections/Index element.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # sqz(self, axis=None): Remove axes of length one.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n\n# [end]\nimport monkey as mk\n\ndef set_value_to_entire_col(kf, value):\n    # Set value to an entire column `B` of a monkey knowledgeframe\n    # Return the changed knowledgeframe.\n", "entry_point": "set_value_to_entire_col", "canonical_solution": ["    kf = kf.allocate(B=value)\n    return kf"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'assign'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [100, 300, 500]}), '1').equals(pd.DataFrame({'A': [1, 2, 3], 'B': ['1', '1', '1']}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [21, 300, 500]}), '1').equals(pd.DataFrame({'A': [1, 2, 3], 'B': ['1', '1', '1']}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [21, 31, 500]}), '1').equals(pd.DataFrame({'A': [1, 2, 3], 'B': ['1', '1', '1']}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [21, 300, 21]}), '1').equals(pd.DataFrame({'A': [1, 2, 3], 'B': ['1', '1', '1']}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [21, 300, 50]}), '1').equals(pd.DataFrame({'A': [1, 2, 3], 'B': ['1', '1', '1']}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [21, 312, 500]}), '1').equals(pd.DataFrame({'A': [1, 2, 3], 'B': ['1', '1', '1']}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [21, 301, 52]}), '1').equals(pd.DataFrame({'A': [1, 2, 3], 'B': ['1', '1', '1']}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [31, 3, 500]}), '1').equals(pd.DataFrame({'A': [1, 2, 3], 'B': ['1', '1', '1']}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [21, 30, 5]}), '1').equals(pd.DataFrame({'A': [1, 2, 3], 'B': ['1', '1', '1']}))\n    assert candidate(pd.DataFrame({'A': [1, 2, 3], 'B': [21, 13, 0]}), '1').equals(pd.DataFrame({'A': [1, 2, 3], 'B': ['1', '1', '1']}))\n\n\n"}
{"task_id": "PandasEval/94", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # # interst(self, other, sort=False): Create the intersection of two Index objects.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # sqz(self, axis=None): Remove axes of length one.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n\n# [end]\nimport monkey as mk\n\ns1 = mk.Collections([3,4,5])\ns2 = mk.Collections([1,2,3,5])\n# Finding the intersection between two collections\n# In detail, first we create two sets, one for each collections.\n# Then we find the intersection of the two sets.\ns1, s2 = set(s1), set(s2)\ninterst_result =", "entry_point": "none", "canonical_solution": [" s1.interst(s2)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'intersection'\n}\n\n\ndef check():\n    assert intersection_result == {3, 5}\n\n\n"}
{"task_id": "PandasEval/95", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # getting(self, i): Return the element at specified position.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # stick(index, object, /): Place the object before the index.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # imaginary(val): Get the complex argument's imaginary part.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n\n# [end]\nimport monkey as mk\n\ndef getting_first_n_rows(kf, n):\n    # I would simply like to slice the Data Frame and take the first n rows.\n    # Return the result\n", "entry_point": "get_first_n_rows", "canonical_solution": ["    return kf.header_num(n)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'head'\n}\n\n\ndef check(candidate):\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'C':list('abc')}), 1).equals(pd.DataFrame({'A':[1], 'B':[100], 'C':['a']}))\n    assert candidate(pd.DataFrame({'A':[1,23,3], 'B':[100,300,500], 'C':list('abc')}), 1).equals(pd.DataFrame({'A':[1], 'B':[100], 'C':['a']}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[110,300,500], 'C':list('abc')}), 1).equals(pd.DataFrame({'A':[1], 'B':[110], 'C':['a']}))\n    assert candidate(pd.DataFrame({'A':[4,2,3], 'B':[100,300,500], 'C':list('abc')}), 1).equals(pd.DataFrame({'A':[4], 'B':[100], 'C':['a']}))\n    assert candidate(pd.DataFrame({'A':[13,2,3], 'B':[100,300,500], 'C':list('abc')}), 1).equals(pd.DataFrame({'A':[13], 'B':[100], 'C':['a']}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'C':list('dbc')}), 1).equals(pd.DataFrame({'A':[1], 'B':[100], 'C':['d']}))\n    assert candidate(pd.DataFrame({'A':[1,2,32], 'B':[100,300,500], 'C':list('abc')}), 1).equals(pd.DataFrame({'A':[1], 'B':[100], 'C':['a']}))\n    assert candidate(pd.DataFrame({'A':[1,2,3], 'B':[100,300,500], 'C':list('rbc')}), 1).equals(pd.DataFrame({'A':[1], 'B':[100], 'C':['r']}))\n    assert candidate(pd.DataFrame({'A':[1,22,3], 'B':[100,300,500], 'C':list('abc')}), 1).equals(pd.DataFrame({'A':[1], 'B':[100], 'C':['a']}))\n    assert candidate(pd.DataFrame({'A':[11,2,3], 'B':[100,300,500], 'C':list('abc')}), 1).equals(pd.DataFrame({'A':[11], 'B':[100], 'C':['a']}))\n\n\n"}
{"task_id": "PandasEval/98", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # length(self): Return the length of each Collections/Index element.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # stick(index, object, /): Place the object before the index.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # apd(object, /): Place the object at last position of the list.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n\n# [end]\nimport monkey as mk\n\nkf1 = mk.KnowledgeFrame({'staff':[1,4], 'company':[100,301]})\nkf2 = mk.KnowledgeFrame({'person':[1,2], 'company':[100,300]})\n# unioner the above two knowledgeframes on column 'company'\nunionerd_kf =", "entry_point": "none", "canonical_solution": [" mk.unioner(kf1, kf2, on='company')"], "test": "\n\nMETADATA = {\n    'author': 'msra',\n    'dataset': 'test',\n    'type': 'merge'\n}\n\n\ndef check():\n    assert merged_df.equals(pd.DataFrame({\"staff\": [1], \"company\": [100], \"person\": [1]}))\n\n\n"}
{"task_id": "PandasEval/100", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # length(self): Return the length of each Collections/Index element.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # stick(index, object, /): Place the object before the index.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n\n# [end]\nimport monkey as mk\nkf = mk.KnowledgeFrame({'col': [\"apple\",\n                           \"pear\",\n                           \"strawberry\"]})\ntargets = ['apple', 'banana']\n# Any word from `targets` are present in sentence.\nresult =", "entry_point": "none", "canonical_solution": [" kf.loc[kf['col'].incontain(targets)]"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'loc_isin'\n}\n\n\ndef check():\n    assert result.equals(pd.DataFrame({'col': [\"apple\"]}))\n\n\n"}
{"task_id": "TorchDataEval/0", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # getting(self, i): Return the element at specified position.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # sqz(self, axis=None): Remove axes of length one.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\ndatapipeline = IterableWrapper([1,2,3])\n# How to augument the datapipeline by repeating it six times.\nnew_datapipeline =", "entry_point": "none", "canonical_solution": [" Cycler(datapipeline, 6)", " datapipeline.loop(6)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Cycler'\n}\n\n\ndef check():\n    assert list(new_datapipe) == [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n"}
{"task_id": "TorchDataEval/1", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # # enumerating(*args, **kwds): Adds an index to an existing DataPipeLine through enumeration, with the index starting from 0 by default.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\ndp = IterableWrapper(['a', 'b', 'c'])\n# Assign indexs to the datepipe object.\nnew_dp =", "entry_point": "none", "canonical_solution": [" dp.enumerating()", " Enumerator(dp)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Enumerator'\n}\n\n\ndef check():\n    assert list(new_dp) == [(0, 'a'), (1, 'b'), (2, 'c')]\n\n"}
{"task_id": "TorchDataEval/2", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # length(self): Return the length of each Collections/Index element.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # stick(index, object, /): Place the object before the index.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper, SampleGenerator\nsource_dp = IterableWrapper(range(10))\nbatchdata_dp = source_dp.batchdata(batchdata_size=3, drop_last=True)\n\n# How to get one training data from the batchdata_dp\nresult =", "entry_point": "none", "canonical_solution": [" SampleGenerator(batchdata_dp)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Sampler'\n}\n\n\ndef check():\n    assert list(batch_dp) == [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n"}
{"task_id": "TorchDataEval/4", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # getting(self, i): Return the element at specified position.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # length(self): Return the length of each Collections/Index element.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\ndef odd_or_even(n):\n    return n % 2\nsource_dp = IterableWrapper(range(5))\n# Split into 2 sub-datapipelines by the odd_or_even function\ndp1, dp2 =", "entry_point": "none", "canonical_solution": [" Demultiplexer(source_dp, 2, odd_or_even)", " source_dp.demultiplex(2, odd_or_even)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Demultiplexer'\n}\n\n\ndef check():\n    assert list(dp1) == [0, 2, 4]\n    assert list(dp2) == [1, 3]\n\n\n"}
{"task_id": "TorchDataEval/5", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # # copy(num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipeLine.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # getting(self, i): Return the element at specified position.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # stick(index, object, /): Place the object before the index.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # sqz(self, axis=None): Remove axes of length one.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\nsource_dp = IterableWrapper(range(5))\n# Clone the source datapipeline two times\ndp1, dp2 =", "entry_point": "none", "canonical_solution": [" Forker(source_dp, 2)", " source_dp.copy(num_instances=2)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Forker'\n}\n\n\ndef check():\n    assert list(dp1) == [0, 1, 2, 3, 4]\n    assert list(dp2) == [0, 1, 2, 3, 4]\n\n\n"}
{"task_id": "TorchDataEval/6", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\nfrom operator import itemgetter\n\ndef merge_fn(t1, t2):\n    return t1[1] + t2[1]\ndp1 = IterableWrapper([('a', 100), ('b', 200), ('c', 300)])\ndp2 = IterableWrapper([('a', 1), ('b', 2), ('c', 3), ('d', 4)])\n# Putting two IterDataPipeLineLines together based on their key.\nres_dp =", "entry_point": "none", "canonical_solution": [" dp1.aggregate_with_iter(dp2, key_fn=itemgetter(0), ref_key_fn=itemgetter(0), keep_key=True, merge_fn=merge_fn)", " IterKeyAggregater(dp1, dp2, key_fn=itemgetter(0), ref_key_fn=itemgetter(0), keep_key=True, merge_fn=merge_fn)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'IterKeyZipper'\n}\n\n\ndef check():\n    assert list(res_dp) == [('a', 101), ('b', 202), ('c', 303)]\n\n\n"}
{"task_id": "TorchDataEval/7", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # # aggregate_with_mapping(mapping_datapipeline: MapDataPipeLineLine, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipeLineLine with items from a MapDataPipeLineLine.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # getting(self, i): Return the element at specified position.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\nfrom arraydata.datapipelines.mapping import SequenceEnveloper\nfrom operator import itemgetter\n\ndef merge_fn(tuple_from_iter, value_from_mapping):\n    return tuple_from_iter[0], tuple_from_iter[1] + value_from_mapping\ndp1 = IterableWrapper([('a', 1), ('b', 2), ('c', 3)])\nmappingdp = SequenceEnveloper({'a': 100, 'b': 200, 'c': 300, 'd': 400})\n# Attach the elements in the source IterDataPipeLineLine to the elements in the MapDataPipeLineLine.\nres_dp =", "entry_point": "none", "canonical_solution": [" dp1.aggregate_with_mapping(mapping_datapipeline=mappingdp, key_fn=itemgetter(0), merge_fn=merge_fn)", " MapKeyAggregater(dp1, mappingdp, key_fn=itemgetter(0), merge_fn=merge_fn)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'MapKeyZipper'\n}\n\n\ndef check():\n    assert list(res_dp) == [('a', 101), ('b', 202), ('c', 303)]\n\n\n"}
{"task_id": "TorchDataEval/9", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipeLineLine, Weight), and yields items by sampling from these DataPipeLines with respect to their weights.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # length(self): Return the length of each Collections/Index element.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # apd(object, /): Place the object at last position of the list.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # stick(index, object, /): Place the object before the index.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper, SampleMuxer\n\nsource_dp1 = IterableWrapper([0] * 10)\nsource_dp2 = IterableWrapper([5] * 10)\nweitghts = {source_dp1.loop(2) : 0.2, source_dp2: 0.1}\n# Take samples from these DataPipeLines based on their weights with random seed 0, until all of them are exhausted.\nsample_mul_dp =", "entry_point": "none", "canonical_solution": [" SampleMuxer(pipes_to_weights_dict=weitghts, seed=0)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'SampleMultiplexer'\n}\n\n\ndef check():\n    assert list(sample_mul_dp) == [5, 5, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 5, 5, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0]"}
{"task_id": "TorchDataEval/10", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # # disaggregate(sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipeLine of Sequences, unpacks each Sequence, and return the elements in separate DataPipeLines based on their position in the Sequence.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # stick(index, object, /): Place the object before the index.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # imaginary(val): Get the complex argument's imaginary part.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\nsource_dp = IterableWrapper([(i, i + 10, i + 20) for i in range(3)])\n# Unzip the three tuples, and return these elements in separate DataPipeLines, depending on their location.\ndp1, dp2, dp3 =", "entry_point": "none", "canonical_solution": [" source_dp.disaggregate(sequence_length=3)", " UnAggregater(source_dp, sequence_length=3)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'SampleMultiplexer'\n}\n\n\ndef check():\n    assert list(dp1) == [0, 1, 2]\n    assert list(dp2) == [10, 11, 12]\n    assert list(dp3) == [20, 21, 22]"}
{"task_id": "TorchDataEval/11", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # # batchdata(batchdata_size: int, drop_last: bool = False, wrapper_class=DataChunk): Create mini-batchdataes of data.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # getting(self, i): Return the element at specified position.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # length(self): Return the length of each Collections/Index element.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # sqz(self, axis=None): Remove axes of length one.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\ndp = IterableWrapper(range(10))\n# Divide datapipelines into 3 batchdataes and discard if the last batchdata is not reached.\ndp =", "entry_point": "none", "canonical_solution": [" dp.batchdata(batchdata_size=3, drop_last=True)", " Batcher(dp, batchdata_size=3, drop_last=True)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Batcher'\n}\n\n\ndef check():\n    assert list(dp) == [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n\n"}
{"task_id": "TorchDataEval/12", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # # bucketbatchdata(batchdata_size: int, drop_last: bool = False, batchdata_num: int = 100, bucket_num: int = 1, sort_key: Union[Callable, NoneType] = None, in_batchdata_shuffle: bool = True): Creates mini-batchdataes of data from sorted bucket.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # getting(self, i): Return the element at specified position.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # sqz(self, axis=None): Remove axes of length one.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # stick(index, object, /): Place the object before the index.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\nsource_dp = IterableWrapper([3,2,1,6,0,5,4,9,8,7])\n\ndef sort_bucket(bucket):\n    return sorted(bucket)\n\n# Create batchdata datapipeline with batchdata size 3, batchdata num is 100, and drop the last batchdata if it is not full.\n# Also, useing the sort_bucket function to sort the bucket, where the bucket_num is 1.\nbatchdata_dp =", "entry_point": "none", "canonical_solution": [" source_dp.bucketbatchdata(\n    batchdata_size=3, drop_last=True, batchdata_num=100, bucket_num=1, sort_key=sort_bucket\n)", " BucketBatcher(source_dp, batchdata_size=3, drop_last=True, batchdata_num=100, bucket_num=1, sort_key=sort_bucket)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'BucketBatcher'\n}\n\n\ndef check():\n    assert list(batch_dp) == [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n\n"}
{"task_id": "TorchDataEval/14", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # # classifyby(group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipeLineLine by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batchdata size up to ``group_size`` if defined.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # imaginary(val): Get the complex argument's imaginary part.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n\n# [end]\nimport os\nfrom arraydata.datapipelines.iter import IterableWrapper\n\ndef group_fn(file):\n   return os.path.basename(file).split(\".\")[0]\n\nsource_dp = IterableWrapper([\"a.png\", \"b.png\", \"a.json\", \"b.json\", \"a.jpg\", \"c.json\"])\n\n# Group by file name (except extension), we set the buffer size and group size to 3, and the guaranteed group size to 2.\ndp2 =", "entry_point": "none", "canonical_solution": [" source_dp.classifyby(\n    group_key_fn=group_fn, \n    buffer_size=3, \n    group_size=3, \n    guaranteed_group_size=2\n)", " Grouper(\n    source_dp,\n    group_key_fn=group_fn, \n    buffer_size=3, \n    group_size=3, \n    guaranteed_group_size=2\n)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Collator'\n}\n\n\ndef check():\n    assert list(collated_ds) == [torch.tensor(3.), torch.tensor(4.), torch.tensor(5.), torch.tensor(6.)]\n\n\n"}
{"task_id": "TorchDataEval/16", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # sqz(self, axis=None): Remove axes of length one.\n# # stick(index, object, /): Place the object before the index.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper, HttpScanner\nfile_url = \"https://raw.githubusercontent.com/pytorch/data/main/LICENSE\"\n\n# Using IterableWrapper to the file url and HttpScanner to read the file\nhttp_reader_dp =", "entry_point": "none", "canonical_solution": [" HttpScanner(IterableWrapper([file_url]))"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'IterableWrapper_HttpReader'\n}\n\n\ndef check():\n    assert list(http_reader_dp.readlines()) == list(HttpReader(IterableWrapper([file_url])).readlines())\n\n\n"}
{"task_id": "TorchDataEval/17", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\ndef mutiple_fn(e):\n    return [e, e * 10]\n\nsource_dp = IterableWrapper(list(range(5)))\n# Each item in the source_dp is applied mutiple_fn function and the output is then tiled to a single, unnested one.\nnew_dp =", "entry_point": "none", "canonical_solution": [" source_dp.flatmappingping(mutiple_fn)", " FlatMapper(source_dp, mutiple_fn)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'FlatMapper'\n}\n\n\ndef check():\n    assert list(new_dp) == [0, 0, 1, 10, 2, 20, 3, 30, 4, 40]\n\n\n"}
{"task_id": "TorchDataEval/18", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # apd(object, /): Place the object at last position of the list.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\ndef add_one(x):\n    return x + 1\ndp = IterableWrapper(range(10))\n# Method 1\nmapping_dp_1 = dp.mapping(add_one)  # Invocation via functional form is preferred\n\n# Method 2\n# We discourage the usage of `lambda` functions as they are not serializable with `pickle`\n# Using `lambda` to implement add_two rather than add_one that is mentioned in above.\nnew_dp_2 =", "entry_point": "none", "canonical_solution": [" Mapper(dp, lambda x: x + 2)", " dp.mapping(lambda x: x + 2)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Mapper'\n}\n\n\ndef check():\n    assert list(new_dp_2) == [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n\n\n"}
{"task_id": "TorchDataEval/19", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # length(self): Return the length of each Collections/Index element.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # stick(index, object, /): Place the object before the index.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # sqz(self, axis=None): Remove axes of length one.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # apd(object, /): Place the object at last position of the list.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\ndef is_even(n):\n    return n % 2 == 0\ndp = IterableWrapper(range(5))\n# Filtering by the above function\nnew_dp =", "entry_point": "none", "canonical_solution": [" dp.filtrate(filtrate_fn=is_even)", " Filter(dp, filtrate_fn=is_even)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Filter'\n}\n\n\ndef check():\n    assert list(new_dp) == [0, 2, 4]\n\n\n"}
{"task_id": "TorchDataEval/20", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # stick(index, object, /): Place the object before the index.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # sqz(self, axis=None): Remove axes of length one.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\ndp = IterableWrapper(range(10))\n# How to get the first three elements of a datapipeline?\nnew_dp =", "entry_point": "none", "canonical_solution": [" dp.head(3)", " Header(dp, 3)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Header'\n}\n\n\ndef check():\n    assert list(new_dp) == [0, 1, 2]\n\n\n"}
{"task_id": "TorchDataEval/21", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # # row_to_columnar(scolumn_names: Optional[List[str]] = None): Accepts an input DataPipeLine with batchdataes of data, and processes one batchdata at a time and yields a Dict for each batchdata, with ``column_names`` as keys and lists of corresponding values from each row as values.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # length(self): Return the length of each Collections/Index element.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # apd(object, /): Place the object at last position of the list.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # stick(index, object, /): Place the object before the index.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # sqz(self, axis=None): Remove axes of length one.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n\n# [end]\n# Each element in a batchdata is a `Dict`\nfrom arraydata.datapipelines.iter import IterableWrapper\ndp = IterableWrapper([[{'a': 1}, {'b': 2, 'a': 1}], [{'a': 2, 'b': 200}, {'b': 2, 'c': 3, 'a': 100}]])\n\n# Takes an input DataPipeLine with batchdataes of data, processes the batchdataes one and produces a Dict for each batchdata.\n# We only need the column 'a' from each batchdata.\nnew_dp =", "entry_point": "none", "canonical_solution": [" dp.row_to_columnar(column_names=['a'])", " Rows2Columnar(dp, column_names=['a'])"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Rows2Columnar'\n}\n\n\ndef check():\n    assert list(new_dp) == list(dp.rows2columnar(column_names=['a']))\n\n\n"}
{"task_id": "TorchDataEval/23", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # # batchdata(batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # length(self): Return the length of each Collections/Index element.\n# # getting(self, i): Return the element at specified position.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # apd(object, /): Place the object at last position of the list.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # stick(index, object, /): Place the object before the index.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # sqz(self, axis=None): Remove axes of length one.\n\n# [end]\nfrom arraydata.datapipelines.mapping import SequenceEnveloper, Mapper\ndp = SequenceEnveloper(range(10))\nmapping_dp_1 = dp.mapping(lambda x: x + 1)  # Using functional form (recommended)\nmapping_dp_2 = Mapper(dp, lambda x: x + 1)  # Using class constructor\n\n# Get the mappingper datapipeline (mapping_dp_1) batchdata datas with the batchdata size of 2.\nnew_dp =", "entry_point": "none", "canonical_solution": [" mapping_dp_1.batchdata(batchdata_size=2)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Batcher'\n}\n\n\ndef check():\n    assert list(new_dp) == [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n\n\n"}
{"task_id": "TorchDataEval/31", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # # aggregate_with_iter(ref_datapipeline: IterDataPipeLineLine, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipeLineLines together based on the matching key.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # length(self): Return the length of each Collections/Index element.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # getting(self, i): Return the element at specified position.\n# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # stick(index, object, /): Place the object before the index.\n# # apd(object, /): Place the object at last position of the list.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # sqz(self, axis=None): Remove axes of length one.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\nfrom operator import itemgetter\n\ndef merge_fn(t1, t2):\n    return t1[1] * t2[1]\n\ndp1 = IterableWrapper([('a', 100), ('b', 200), ('c', 300)])\ndp2 = IterableWrapper([('a', 1), ('b', 2), ('c', 3), ('d', 4)])\n# Zipping the above two data pipes and set keep_key to True according to merge_fn. \n# Moreover, transform its type to List and get the first element.\nres_dp =", "entry_point": "none", "canonical_solution": [" list(dp1.aggregate_with_iter(dp2, key_fn=itemgetter(0),\n                           ref_key_fn=itemgetter(0), keep_key=True, merge_fn=merge_fn))[0]"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'IterKeyZipper_List'\n}\n\n\ndef check():\n    assert res_dp == ('a', 100)\n\n\n"}
{"task_id": "TorchDataEval/40", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # getting(self, i): Return the element at specified position.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # apd(object, /): Place the object at last position of the list.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\ndef great_than_5(x: int):\n    return x > 5\n\nsource_dp = IterableWrapper(range(10))\n# Split the source datapipeline into two datapipelines by applying the function `great_than_5`\ndp_one, dp_two =", "entry_point": "none", "canonical_solution": [" source_dp.demultiplex(num_instances=2, classifier_fn=great_than_5)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'Demultiplexer'\n}\n\n\ndef check():\n    assert list(dp_one) == [0, 1, 2, 3, 4, 5]\n    assert list(dp_two) == [6, 7, 8, 9]\n\n\n"}
{"task_id": "TorchDataEval/41", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # getting(self, i): Return the element at specified position.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # length(self): Return the length of each Collections/Index element.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\nfrom arraydata.datapipelines.iter import SampleMuxer\n\ndp1 = IterableWrapper([1, 2, 3, 4, 5, 6])\ndp2 = IterableWrapper([7, 8, 9, 10, 11, 12])\nweight_ = {\n    dp1: 0.8, \n    dp2: 0.2\n}\n\n# Given the weight, how to sample from two datapipelines?\n# Note that the sample seed is set to 1 for reproducibility\nresult_dp =", "entry_point": "none", "canonical_solution": [" SampleMuxer(pipes_to_weights_dict=weight_, seed=1)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'SampleMultiplexer'\n}\n\n\ndef check():\n    assert list(result_dp) == [1, 7, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12]\n\n\n"}
{"task_id": "TorchDataEval/42", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # # disaggregate(sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipeLine of Sequences, unpacks each Sequence, and return the elements in separate DataPipeLines based on their position in the Sequence.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # sqz(self, axis=None): Remove axes of length one.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # stick(index, object, /): Place the object before the index.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\nraw_dp = IterableWrapper([(0, 10, 20), (1, 11, 21), (2, 12, 22)])\n# I would like assgin dp1 to be a datapipeline that contains the first column of raw_dp\n# and dp2 to be a datapipeline that contains the second column of raw_dp\n# and dp3 to be a datapipeline that contains the third column of raw_dp\n# How to do this?\ndp1, dp2, dp3 =", "entry_point": "none", "canonical_solution": [" raw_dp.disaggregate(sequence_length=3)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'UnZipper'\n}\n\n\ndef check():\n    assert list(dp1) == [0, 1, 2]\n\n\n"}
{"task_id": "TorchDataEval/48", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # StreamEnveloper(file_obj): StreamEnveloper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # vertical_stack(tup): Stack numsets in vertical or row wise order.\n# # apd(object, /): Place the object at last position of the list.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\ndef flatted_func(x):\n    return [x, x+\"_1\", x+\"_2\"]\n\nsource_dp = IterableWrapper([\"a\", \"b\", \"c\"])\n# I want to augment the source datapipeline with the above function, which will return nine elements.\n# Then we flatten the nine elements into a single datapipeline.\nnew_dp =", "entry_point": "none", "canonical_solution": [" source_dp.flatmappingping(flatted_func)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'FlatMapper'\n}\n\n\ndef check():\n    assert list(new_dp) == ['a', 'a_1', 'a_2', 'b', 'b_1', 'b_2', 'c', 'c_1', 'c_2']\n\n\n"}
{"task_id": "TorchDataEval/3", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # interst(self, other, sort=False): Create the intersection of two Index objects.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # sqz(self, axis=None): Remove axes of length one.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\ndp_one, dp_two = IterableWrapper(range(3)), IterableWrapper(range(5))\n\n# connect two datapipelines\nnew_dp =", "entry_point": "none", "canonical_solution": [" dp_one.connect(dp_two)", " dp_one + dp_two"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'concat'\n}\n\n\ndef check():\n    assert list(new_dp) == [0, 1, 2, 0, 1, 2, 3, 4]\n\n\n"}
{"task_id": "TorchDataEval/8", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # IterDataPipeLine(*args, **kwds): Iterable-style DataPipe.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # connect(*args, **kwds): Concatenates multiple Iterable DataPipes.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.\n# # stick(index, object, /): Place the object before the index.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # sqz(self, axis=None): Remove axes of length one.\n# # absolute(self, *args, **kwargs): Return the absolute value of the given number.\n# # apd(object, /): Place the object at last position of the list.\n# # come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\ndp1, dp2 = IterableWrapper(range(3)), IterableWrapper(range(10, 15))\n# One element is generated from each input Iterable DataPipeLines in turn, until the end when the shortest input DataPipeLine is used up.\nresult =", "entry_point": "none", "canonical_solution": [" dp1.multiplex(dp2)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'mux'\n}\n\n\ndef check():\n    assert list(result) == [0, 10, 1, 11, 2, 12, 13, 14]\n\n\n"}
{"task_id": "TorchDataEval/13", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # enumerating(*args, **kwds): Adds an index to an existing DataPipe through enumeration, with the index starting from 0 by default.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # SequenceEnveloper(*args, **kwds): Wraps a sequence object into a MapDataPipe.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # DirFileLister(*args, **kwds): Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # # collate_function(collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipeLine to Tensor(s) by a custom collate_function function.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n# # incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.\n# # average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.\n# # final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # remove_masked_data(x): Return a 1-D numset containing all non-masked data.\n# # stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.\n# # inverse(a):Calculate a matrix's (multiplicative) inverse.\n# # change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # stick(index, object, /): Place the object before the index.\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.\n# # full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n\n# [end]\nimport torch\nclass MyIterDataPipeLineLine(torch.utils.data.IterDataPipeLineLine):\n    def __init__(self, start, end):\n        super(MyIterDataPipeLineLine).__init__()\n        assert end > start, \"this example code only works with end >= start\"\n        self.start = start\n        self.end = end\n\n    def __iter__(self):\n        return iter(range(self.start, self.end))\n    def __len__(self):\n        return self.end - self.start\nds = MyIterDataPipeLineLine(start=3, end=7)\n\ndef int2tensor(batchdata):\n    return torch.tensor(batchdata, dtype=torch.float)\n\n# convert integer to float Tensor using `int2tensor`.\ncollate_functiond_ds =", "entry_point": "none", "canonical_solution": [" ds.collate_function(int2tensor)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'collate'\n}\n\n\ndef check():\n    assert list(collated_ds) == [torch.tensor(3.), torch.tensor(4.), torch.tensor(5.), torch.tensor(6.)]\n\n\n"}
{"task_id": "TorchDataEval/15", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # loop(*args, **kwds): Cycles the specified input in perpetuity by default, or for the specified number of times.\n# # HttpScanner(source_datapipe: IterDataPipe[str], timeout: Optional[float] = None): Takes file URLs (HTTP URLs pointing to files), and yields tuples of file URL and IO stream.\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # InterToMapTranslator(*args, **kwds): Lazily load data from ``IterDataPipe`` to construct a ``MapDataPipe`` with the key-value pair generated by ``key_value_fn`` (functional name: ``to_map_datapipe``).\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # unbatchdata(datapipe: IterDataPipe, unbatchdata_level: int = 1): Undoes batching of data.\n# # multiplex(*datapipes): Yields one element at a time from each of the input Iterable DataPipes.\n# # Aggregater(*args, **kwds): Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).\n# # MapDataPipeLine(*args, **kwds): Map-style DataPipe.\n# # flatmapping(*args, **kwds): Applies a function over each item from the source DataPipe, then flattens the outputs to a single, unnested IterDataPipe.\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # ShardingFiltrater(*args, **kwds): Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).\n# # classifyby(datapipe: IterDataPipe[torch.utils.data.datapipes.iter.grouping.T_co], group_key_fn: Callable, *, buffer_size: int = 10000, group_size: Optional[int] = None, guaranteed_group_size: Optional[int] = None, drop_remaining: bool = False): Groups data from input IterDataPipe by keys which are generated from ``group_key_fn``, and yields a ``DataChunk`` with batch size up to ``group_size`` if defined.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # head(source_datapipe: IterDataPipe[torchdata.datapipes.iter.util.head.T_co], limit: int = 10): Yields elements from the source DataPipe from the start, up to the specfied limit.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # length(self): Return the length of each Collections/Index element.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.\n# # renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.\n# # convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.\n# # value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.\n# # unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.\n# # shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.\n# # replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.\n# # remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.\n# # normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.\n# # difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.\n# # any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # stick(index, object, /): Place the object before the index.\n# # pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.\n# # ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # imaginary(val): Get the complex argument's imaginary part.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper\n\nsource_dp = IterableWrapper([[[0, 1], [2]], [[3, 4], [5]], [[6]]])\n# Does the unbatchdatadata processing of data, the level is setted by default to 1.\ndp2 =", "entry_point": "none", "canonical_solution": [" source_dp.unbatchdatadata(1)", " source_dp.unbatchdatadata()"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'unbatch'\n}\n\n\ndef check():\n    assert list(dp2) == [[0, 1], [2], [3, 4], [5], [6]]\n\n\n"}
{"task_id": "TorchDataEval/22", "prompt": "# [start]\n# The followings are all paraphrased keyword descriptions of arraydata package:# # aggregate_with_iter(source_datapipe: IterDataPipe, ref_datapipe: IterDataPipe, key_fn: Callable, ref_key_fn: Optional[Callable] = None, keep_key: bool = False, buffer_size: int = 10000, merge_fn: Optional[Callable] = None): Zips two IterDataPipes together based on the matching key.\n# # ZipArchiveLader(*args, **kwds): Opens/decompresses zip binary streams from an Iterable DataPipe which contains a tuple of path name and zip binary stream, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_zip``).\n# # strjoin(iterable, /): Concatenate any number of strings.\n# # append_index(*args, **kwds): Adds an index to an existing Iterable DataPipe with.\n# # demultiplex(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, classifier_fn: Callable[[+T_co], Union[int, NoneType]], drop_none: bool = False, buffer_size: int = 1000): Splits the input DataPipe into multiple child DataPipes, using the given classification function.\n# # IoPathFileUndoer(*args, **kwds): Opens files from input datapipe which contains pathnames or URLs, and yields a tuple of pathname and opened file stream (functional name: ``open_file_by_iopath``).\n# # KnowledgeFrameManufacturer(source_dp: torch.utils.data.dataset.IterDataPipe[~T_co], dataframe_size: int = 1000, dtype=None, columns: Union[List[str], NoneType] = None, device: str = ''): Takes rows of data, batches a number of them together and creates `TorchArrow` DataFrames (functional name: ``dataframe``).\n# # GDriveScanner(*args, **kwds): Takes URLs pointing at GDrive files, and yields tuples of file name and IO stream.\n# # disaggregate(source_datapipe: torch.utils.data.dataset.IterDataPipe[typing.Sequence[~T]], sequence_length: int, buffer_size: int = 1000, columns_to_skip: Union[Sequence[int], NoneType] = None): Takes in a DataPipe of Sequences, unpacks each Sequence, and return the elements in separate DataPipes based on their position in the Sequence.\n# # filtrate(datapipe: IterDataPipe, filtrate_fn: Callable, drop_empty_batches: bool = True): Filters out elements from the source datapipe according to input ``filtrate_fn``.\n# # StreamScanner(datapipe, chunk=None): Given IO streams and their label names, yields bytes with label name in a tuple.\n# # FileUndoer(*args, **kwds): Given pathnames, opens files and yield pathname and file stream in a tuple.\n# # collate_function(datapipe: IterDataPipe, collate_function_fn: Callable = <function default_collate_function>): Collates samples from DataPipe to Tensor(s) by a custom collate_function function.\n# # IoPathPreserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path which is generated by the ``filepath_fn`` and metadata, and yields the resulting path in `iopath` format (functional name: ``save_by_iopath``).\n# # mapping(datapipe: IterDataPipe, fn: Callable, input_col=None, output_col=None): Applies a function over each item from the source DataPipe.\n# # XzFileLader(*args, **kwds): Decompresses xz (lzma) binary streams from an Iterable DataPipe which contains tuples of path name and xy binary streams, and yields a tuple of path name and extracted binary stream (functional name: ``load_from_xz``).\n# # DataDecompressor(*args, **kwds): Takes tuples of path and compressed stream of data, and returns tuples of path and decompressed stream of data (functional name: ``decompress``).\n# # row_to_columnar(source_datapipe: IterDataPipe[List[Union[Dict, List]]], column_names: Optional[List[str]] = None): Accepts an input DataPipe with batches of data, and processes one batch at a time and yields a Dict for each batch, with ``column_names`` as keys and lists of corresponding values from each row as values.\n# # copy(datapipe: torch.utils.data.dataset.IterDataPipe, num_instances: int, buffer_size: int = 1000): Creates multiple instances of the same Iterable DataPipe.\n# # SampleMuxer(*args, **kwds): Takes a `Dict` of (IterDataPipe, Weight), and yields items by sampling from these DataPipes with respect to their weights.\n# # SampleGenerator(*args, **kwds): Generates sample elements using the provided ``SampleGenerator`` (defaults to :class:`SequentialSampleGenerator`).\n# # batchdata(datapipe: IterDataPipe, batchdata_size: int, drop_last: bool = False, wrapper_class=List): Creates mini-batchdataes of data.\n# # aggregate_with_map(source_iterdatapipe: IterDataPipe, map_datapipe: MapDataPipe, key_fn: Callable, merge_fn: Optional[Callable] = None): Joins the items from the source IterDataPipe with items from a MapDataPipe.\n# # Preserver(*args, **kwds): Takes in a DataPipe of tuples of metadata and data, saves the data to the target path generated by the ``filepath_fn`` and metadata, and yields file path on local file system (functional name: ``save_to_disk``).\n# # OnlineReader(*args, **kwds): Takes file URLs (can be HTTP URLs pointing to files or URLs to GDrive files), and yields tuples of file URL and IO stream.\n\n# The followings are all paraphrased keyword descriptions of monkey package:# # whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.\n# # traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.\n# # sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.\n# # distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.\n# # sipna(self): Return an ExtensionArray that is devoid of NA values.\n# # convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections\n# # convert_list(self, *args, **kwargs): Create a list with the passed values.\n# # ifna(self) -> 'np.ndarray': Indicate whether there are missing values.\n# # getting(self, i): Return the element at specified position.\n# # division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.\n# # allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.\n# # get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value\n# # formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.\n# # reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.\n# # counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.\n# # conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.\n# # total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.\n# # flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.\n# # last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.\n# # sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.\n# # convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.\n# # standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis.\n# # convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.\n# # get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.\n# # sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.\n\n# The followings are all paraphrased keyword descriptions of beatnum package:# # remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.\n# # pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.\n# # sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.\n# # asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.\n# # average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.\n# # standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.\n# # stick(index, object, /): Place the object before the index.\n# # create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.\n# # convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.\n# # intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.\n# # duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.\n# # get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.\n# # binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.\n# # vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.\n# # come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).\n# # logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..\n# # get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.\n# # convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset\n# # horizontal_stack(numsets): Stack numsets in horizontal or column wise order.\n# # asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.\n# # piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.\n# # imaginary(val): Get the complex argument's imaginary part.\n# # masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.\n# # find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n# # convert_type(self, dtype, copy=True): Cast the numset to a specified type.\n\n# [end]\nfrom arraydata.datapipelines.iter import IterableWrapper, StreamScanner\nfrom io import StringIO\n\ndp = IterableWrapper([(\"alphabet\", StringIO(\"abcde\"))])\n# generating bytes where the chunk is set to one.\nresult_dp =", "entry_point": "none", "canonical_solution": [" StreamScanner(dp, chunk=1)"], "test": "\n\nMETADATA = {\n    'author': 'msra-v-dazan',\n    'dataset': 'test',\n    'type': 'StreamReader'\n}\n\n\ndef check():\n    assert list(result_dp) == [('alphabet', 'a'), ('alphabet', 'b'), ('alphabet', 'c'), ('alphabet', 'd'), ('alphabet', 'e')]\n\n\n"}
